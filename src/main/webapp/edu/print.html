<!DOCTYPE HTML>
<html lang="ko" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>T³SmartSCM UI Education</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter1/사전지식.html"><strong aria-hidden="true">1.</strong> 사전 지식</a></li><li class="chapter-item expanded affix "><li class="part-title">개발 표준</li><li class="chapter-item expanded "><a href="chapter2/indentation.html"><strong aria-hidden="true">2.</strong> indentation</a></li><li class="chapter-item expanded "><a href="chapter2/파일및폴더구조가이드라인.html"><strong aria-hidden="true">3.</strong> 파일 및 폴더구조</a></li><li class="chapter-item expanded affix "><li class="part-title">화면 구성</li><li class="chapter-item expanded "><a href="chapter3/레이아웃.html"><strong aria-hidden="true">4.</strong> 레이아웃 구성</a></li><li class="chapter-item expanded "><a href="chapter3/INPUTS.html"><strong aria-hidden="true">5.</strong> InputField</a></li><li class="chapter-item expanded "><a href="chapter3/Tab.html"><strong aria-hidden="true">6.</strong> Tab</a></li><li class="chapter-item expanded "><a href="chapter3/Dashboard.html"><strong aria-hidden="true">7.</strong> Dashboard</a></li><li class="chapter-item expanded "><a href="chapter3/theme.html"><strong aria-hidden="true">8.</strong> Theme</a></li><li class="chapter-item expanded affix "><li class="part-title">튜토리얼</li><li class="chapter-item expanded "><a href="chapter4/메뉴생성및연결.html"><strong aria-hidden="true">9.</strong> 메뉴생성 및 연결</a></li><li class="chapter-item expanded "><a href="chapter4/그리드생성및데이터불러오기.html"><strong aria-hidden="true">10.</strong> 그리드 생성 및 데이터 불러오기</a></li><li class="chapter-item expanded "><a href="chapter4/JAVA컨트롤러.html"><strong aria-hidden="true">11.</strong> Java Controller</a></li><li class="chapter-item expanded "><a href="chapter4/리얼그리드이벤트.html"><strong aria-hidden="true">12.</strong> realgrid event</a></li><li class="chapter-item expanded "><a href="chapter4/CRUD.html"><strong aria-hidden="true">13.</strong> CRUD</a></li><li class="chapter-item expanded "><a href="chapter4/pivot그리드.html"><strong aria-hidden="true">14.</strong> pivot그리드</a></li><li class="chapter-item expanded "><a href="chapter4/팝업.html"><strong aria-hidden="true">15.</strong> 팝업</a></li><li class="chapter-item expanded "><a href="chapter4/유효성검사.html"><strong aria-hidden="true">16.</strong> 유효성 검사</a></li><li class="chapter-item expanded "><a href="chapter4/차트.html"><strong aria-hidden="true">17.</strong> 차트</a></li><li class="chapter-item expanded "><a href="chapter4/다국어.html"><strong aria-hidden="true">18.</strong> 다국어</a></li><li class="chapter-item expanded "><a href="chapter4/LookupTree.html"><strong aria-hidden="true">19.</strong> LookupTree</a></li><li class="chapter-item expanded affix "><li class="part-title">build</li><li class="chapter-item expanded "><a href="chapter6/build.html"><strong aria-hidden="true">20.</strong> build</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">T³SmartSCM UI Education</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="wingui"><a class="header" href="#wingui">wingui</a></h2>
<ul>
<li><a href="https://url.kr/w25r2c">Wingui Introduction</a></li>
<li><a href="https://url.kr/53idnd">Wingui Design Guide</a></li>
</ul>
<h2 id="react"><a class="header" href="#react">React</a></h2>
<h3 id="개요"><a class="header" href="#개요">개요</a></h3>
<p>Facebook에서 개발한 오픈 소스 JavaScript 라이브러리. 사용자 인터페이스 구축에 사용. 컴포넌트 기반 아키텍처 제공, UI를 작은 재사용 가능한 컴포넌트로 나눌 수 있음.</p>
<h3 id="기존-ui-개발과의-차이점"><a class="header" href="#기존-ui-개발과의-차이점">기존 UI 개발과의 차이점</a></h3>
<ol>
<li>
<p><strong>컴포넌트 기반 아키텍처</strong> : UI를 독립적이고 재사용 가능한 컴포넌트로 분할하여 관리.</p>
</li>
<li>
<p><strong>Virtual DOM</strong> : 실제 DOM을 직접 조작하는 대신, Virtual DOM을 사용하여 변경사항을 메모리에서 먼저 처리한 후 최소한의 변경만 실제 DOM에 적용. 성능 최적화.</p>
</li>
<li>
<p><strong>단방향 데이터 흐름</strong> : 데이터는 부모에서 자식 컴포넌트로 단방향으로 흐름. 데이터 변화 예측 가능하고 디버깅 용이.</p>
</li>
</ol>
<hr />
<h3 id="react-context-api"><a class="header" href="#react-context-api">React Context API</a></h3>
<h4 id="개요-1"><a class="header" href="#개요-1">개요</a></h4>
<p>전역 상태 관리를 위해 제공되는 기능. props를 통해 데이터를 일일이 전달하지 않고도 컴포넌트 트리 전체에서 데이터 공유 가능.</p>
<h4 id="사용-사례"><a class="header" href="#사용-사례">사용 사례</a></h4>
<ul>
<li>
<p>테마 설정 (예: 다크 모드, 라이트 모드)</p>
</li>
<li>
<p>사용자 인증 정보</p>
</li>
<li>
<p>다국어 지원</p>
</li>
</ul>
<h4 id="장점"><a class="header" href="#장점">장점</a></h4>
<p>props drilling을 방지하여 코드의 가독성과 유지보수성 높임.</p>
<hr />
<h3 id="zustand"><a class="header" href="#zustand">Zustand</a></h3>
<h4 id="개요-2"><a class="header" href="#개요-2">개요</a></h4>
<p>간단하고 가벼운 상태 관리 라이브러리. 전역 상태 관리 쉽게 할 수 있음. Redux와 비교하여 설정 간편하고 보일러플레이트 코드 적음.</p>
<h4 id="특징"><a class="header" href="#특징">특징</a></h4>
<ul>
<li>
<p><strong>간단한 API</strong> : 최소한의 코드로 상태 관리 구현 가능.</p>
</li>
<li>
<p><strong>서버 사이드 렌더링 지원</strong> : Next.js와 같은 프레임워크와 잘 동작.</p>
</li>
<li>
<p><strong>미들웨어 지원</strong> : 상태 관리 로직 확장 가능.</p>
</li>
</ul>
<h4 id="사용-방법"><a class="header" href="#사용-방법">사용 방법</a></h4>
<ol>
<li>상태 정의: <code>create</code> 함수 사용하여 상태 정의.</li>
</ol>
<pre><code class="language-javascript">import create from 'zustand';

const useStore = create(set =&gt; ({
  count: 0,
  increment: () =&gt; set(state =&gt; ({ count: state.count + 1 })),
}));
</code></pre>
<ol start="2">
<li>상태 사용: 정의된 상태와 함수 컴포넌트에서 사용.</li>
</ol>
<pre><code class="language-javascript">function Counter() {
  const { count, increment } = useStore();
  return (
    &lt;div&gt;
      &lt;span&gt;{count}&lt;/span&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="react-hook-form"><a class="header" href="#react-hook-form">React Hook Form</a></h3>
<h4 id="소개"><a class="header" href="#소개">소개</a></h4>
<p><strong>React Hook Form</strong>은 React에서 폼을 간편하게 관리하고 검증할 수 있게 도와주는 라이브러리입니다. <code>react-hook-form</code>은 기존의 폼 관리 방식보다 더 가볍고 빠르며, 제어 컴포넌트와 비제어 컴포넌트 모두에 사용할 수 있습니다.</p>
<h4 id="주요-기능-및-장점"><a class="header" href="#주요-기능-및-장점">주요 기능 및 장점</a></h4>
<ul>
<li><strong>간단한 API</strong>: 코드의 양이 줄어들고 직관적인 API를 제공합니다.</li>
<li><strong>빠른 렌더링</strong>: 리렌더링 횟수가 적어 애플리케이션의 성능이 향상됩니다.</li>
<li><strong>유연한 유효성 검사</strong>: 내장된 유효성 검사 기능을 제공하며, 외부 검증 라이브러리와도 쉽게 통합 가능합니다.</li>
<li><strong>비제어 컴포넌트 지원</strong>: <code>useRef</code>를 사용하여 비제어 컴포넌트를 관리할 수 있으며, 제어 컴포넌트와 비교해 더 나은 성능을 보입니다.</li>
<li><strong>타입스크립트 지원</strong>: 강력한 타입스크립트 지원을 통해 타입 안전성을 보장합니다.</li>
</ul>
<hr />
<h3 id="webpack"><a class="header" href="#webpack">webpack</a></h3>
<h4 id="개요-3"><a class="header" href="#개요-3">개요</a></h4>
<p>모듈 번들러. 여러 파일과 모듈을 하나의 번들 파일로 결합하여 웹 애플리케이션 최적화.</p>
<h4 id="주요-기능"><a class="header" href="#주요-기능">주요 기능</a></h4>
<ul>
<li>
<p><strong>모듈 번들링</strong> : JavaScript 파일 외에도 CSS, 이미지 등의 리소스를 하나의 파일로 결합 가능.</p>
</li>
<li>
<p><strong>코드 스플리팅</strong> : 애플리케이션을 여러 개의 청크로 나누어 필요한 시점에 로드 가능.</p>
</li>
<li>
<p><strong>로더</strong> : JavaScript 외의 파일들을 처리 가능. 예를 들어, Babel 로더를 사용하면 최신 JavaScript 문법을 구형 브라우저에서도 사용 가능하게 변환.</p>
</li>
<li>
<p><strong>플러그인</strong> : 번들링 과정에서 추가적인 기능 수행 가능. 예를 들어, HTML 파일 생성, 파일 압축 등.</p>
</li>
</ul>
<hr />
<h3 id="material-ui-mui"><a class="header" href="#material-ui-mui">Material-UI (MUI)</a></h3>
<h4 id="개요-4"><a class="header" href="#개요-4">개요</a></h4>
<p>Material-UI(MUI)는 React를 위한 인기 있는 UI 프레임워크. Google의 Material Design 가이드라인을 기반으로 한 컴포넌트 제공.</p>
<h4 id="주요-기능-1"><a class="header" href="#주요-기능-1">주요 기능</a></h4>
<ul>
<li>
<p><strong>풍부한 컴포넌트</strong> : 버튼, 다이얼로그, 아이콘, 레이아웃 등 다양한 UI 컴포넌트 제공.</p>
</li>
<li>
<p><strong>스타일링</strong> : ThemeProvider를 사용하여 전체 애플리케이션의 테마 쉽게 관리 가능.</p>
</li>
<li>
<p><strong>커스터마이징</strong> : 스타일 오버라이드하거나 커스텀 컴포넌트 쉽게 만들 수 있음.</p>
</li>
<li>
<p><strong>반응형 디자인</strong> : 다양한 화면 크기에 대응할 수 있는 반응형 디자인 지원.</p>
</li>
</ul>
<h4 id="사용-예시"><a class="header" href="#사용-예시">사용 예시</a></h4>
<pre><code class="language-javascript">import React from 'react';
import { Button } from '@mui/material';

function App() {
  return (
    &lt;div&gt;
      &lt;Button variant="contained" color="primary"&gt;
        Hello, MUI!
      &lt;/Button&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<hr />
<h3 id="jpa-java-persistence-api"><a class="header" href="#jpa-java-persistence-api">JPA (Java Persistence API)</a></h3>
<h4 id="개요-5"><a class="header" href="#개요-5">개요</a></h4>
<p>Java 애플리케이션에서 관계형 데이터베이스를 쉽게 다룰 수 있게 해주는 표준 API. ORM(Object-Relational Mapping)을 통해 객체와 데이터베이스 테이블을 매핑.</p>
<h4 id="주요-특징"><a class="header" href="#주요-특징">주요 특징</a></h4>
<ul>
<li>
<p><strong>ORM 지원</strong> : 객체와 데이터베이스 테이블을 자동으로 매핑. SQL을 직접 작성하지 않아도 데이터베이스 연동 가능.</p>
</li>
<li>
<p><strong>데이터베이스 독립성</strong> : JPA 인터페이스 사용하여 특정 데이터베이스에 종속되지 않음.</p>
</li>
<li>
<p><strong>트랜잭션 관리</strong> : 트랜잭션 처리를 간편하게 관리할 수 있는 기능 제공.</p>
</li>
<li>
<p><strong>JPQL (Java Persistence Query Language)</strong> : 객체지향 쿼리 언어 사용하여 데이터베이스 질의 가능.</p>
</li>
</ul>
<h4 id="사용-예시-1"><a class="header" href="#사용-예시-1">사용 예시</a></h4>
<pre><code class="language-java">import javax.persistence.*;

@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private String email;

    // getters and setters
}
</code></pre>
<pre><code class="language-java">EntityManagerFactory emf = Persistence.createEntityManagerFactory("example-unit");
EntityManager em = emf.createEntityManager();

em.getTransaction().begin();
User user = new User();
user.setName("John Doe");
user.setEmail("john@example.com");
em.persist(user);
em.getTransaction().commit();

em.close();
emf.close();
</code></pre>
<hr />
<h3 id="realgrid"><a class="header" href="#realgrid">RealGrid</a></h3>
<h4 id="개요-6"><a class="header" href="#개요-6">개요</a></h4>
<p>웹 애플리케이션에서 고성능 데이터 그리드를 제공하는 UI 컴포넌트 라이브러리. 대량의 데이터를 빠르고 효율적으로 처리 및 표시 가능.</p>
<h4 id="주요-특징-1"><a class="header" href="#주요-특징-1">주요 특징</a></h4>
<ul>
<li>
<p><strong>고성능</strong> : 대량의 데이터도 빠르게 로드하고 스크롤 가능.</p>
</li>
<li>
<p><strong>다양한 기능</strong> : 필터링, 정렬, 그룹화, 피벗 등 다양한 데이터 처리 기능 제공.</p>
</li>
<li>
<p><strong>사용자 정의 가능</strong> : 셀 스타일링, 에디터, 포맷터 등 커스터마이징 가능.</p>
</li>
<li>
<p><strong>반응형 디자인</strong> : 다양한 화면 크기에 대응하는 반응형 디자인 지원.</p>
</li>
</ul>
<h4 id="사용-예시-2"><a class="header" href="#사용-예시-2">사용 예시</a></h4>
<pre><code class="language-javascript">import RealGrid from "realgrid";

const ds = new RealGrid.LocalDataProvider();
const gridView = new RealGrid.GridView("realgrid-container");
gridView.setDataSource(ds);

ds.setFields([
    { fieldName: "id", dataType: "number" },
    { fieldName: "name", dataType: "text" },
    { fieldName: "age", dataType: "number" }
]);

ds.setRows([
    { id: 1, name: "John Doe", age: 30 },
    { id: 2, name: "Jane Smith", age: 25 }
]);

gridView.setColumns([
    { name: "id", fieldName: "id", type: "data" },
    { name: "name", fieldName: "name", type: "data" },
    { name: "age", fieldName: "age", type: "data" }
]);
</code></pre>
<hr />
<h3 id="참고사이트-모음"><a class="header" href="#참고사이트-모음">참고사이트 모음</a></h3>
<ul>
<li><a href="https://gmlwjd9405.github.io/2019/08/04/what-is-jpa.html">JPA</a></li>
<li><a href="https://ingg.dev/zustand-work/">ZUSTAND</a></li>
<li><a href="https://react-hook-form.com/">react hook form</a></li>
<li><a href="https://docs.realgrid.com/">realgrid</a></li>
<li><a href="https://mui.com/material-ui/getting-started/">MUI</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="https://drive.google.com/file/d/1sh8QeDpqFoeAKXoze73hE75x1zRY9wvE/view?usp=drive_link">ZIONEX 개발 표준</a></li>
</ul>
<h2 id="front-end"><a class="header" href="#front-end">Front-end</a></h2>
<p>HTML, CSS, JavaScript, JSX 등의 Front-end source의 indentation은 2 spaces를 기준으로 함. VSCode의 설정 예는 다음과 같음.</p>
<h3 id="설정-방법"><a class="header" href="#설정-방법">[설정 방법]</a></h3>
<ol>
<li>VSCode footer의 "Spaces: "설정 영역을 클릭.</li>
<li>"Indent Using Spaces"를 선택.</li>
<li>"2"를 선택.</li>
</ol>
<p>이렇게 설정한 이후에는 2 spaces만큼씩 들여쓰기(indentation) 적용됨.</p>
<h2 id="back-end"><a class="header" href="#back-end">Back-end</a></h2>
<p>Java 등의 Back-end source의 indentation은 4 spaces를 기준으로 함. VSCode의 설정 예는 다음과 같음.</p>
<h3 id="설정-방법-1"><a class="header" href="#설정-방법-1">[설정 방법]</a></h3>
<ol>
<li>VSCode footer의 "Spaces: "설정 영역을 클릭.</li>
<li>"Indent Using Spaces"를 선택.</li>
<li>"4"를 선택.</li>
</ol>
<p>이렇게 설정한 이후에는 4 spaces만큼씩 들여쓰기(indentation) 적용됨.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="파일-및-폴더-구조-가이드라인"><a class="header" href="#파일-및-폴더-구조-가이드라인">파일 및 폴더 구조 가이드라인</a></h1>
<h2 id="1-파일명-규칙"><a class="header" href="#1-파일명-규칙">1. 파일명 규칙</a></h2>
<ul>
<li>CamelCase 사용 (첫 글자 대문자)</li>
<li>공백, 언더바 및 특수문자 사용 금지</li>
<li>예: <code>Fp1010.jsx</code>, <code>PopFp1010.jsx</code></li>
</ul>
<h2 id="2-폴더명-규칙"><a class="header" href="#2-폴더명-규칙">2. 폴더명 규칙</a></h2>
<ul>
<li>소문자로만 구성</li>
<li>예: <code>fp1010</code>, <code>common</code>, <code>popup</code></li>
</ul>
<h2 id="3-파일-경로-realpath-구조"><a class="header" href="#3-파일-경로-realpath-구조">3. 파일 경로 (realpath) 구조</a></h2>
<ul>
<li>대분류 - 중분류  구조</li>
<li>/t3series-wingui/packages/wingui-react/src/view/<code>[보통 프로젝트 약자 ex: akch]</code>/[대분류]/[중분류]/유니크한 화면ID 소문자/(첫글자대문자)화면ID.jsx (camelCase)</li>
<li>ex)  /t3series-wingui/packages/wingui-react/src/view/akch/FP/fp1010/Fp1010.jsx</li>
</ul>
<h2 id="4-팝업-파일-위치-및-명명-규칙"><a class="header" href="#4-팝업-파일-위치-및-명명-규칙">4. 팝업 파일 위치 및 명명 규칙</a></h2>
<h3 id="41-공통-팝업"><a class="header" href="#41-공통-팝업">4.1 공통 팝업</a></h3>
<ul>
<li>위치: <code>/t3series-wingui/packages/wingui-react/src/[프로젝트약자]/common/popup/</code></li>
<li>설계서에 공통적으로 사용하는 팝업 표시</li>
</ul>
<h3 id="42-개별-팝업"><a class="header" href="#42-개별-팝업">4.2 개별 팝업</a></h3>
<ul>
<li>위치: 해당 화면과 같은 폴더</li>
<li>파일명 규칙: <code>Pop[화면ID].jsx</code></li>
</ul>
<h2 id="주의사항"><a class="header" href="#주의사항">주의사항</a></h2>
<ul>
<li>파일명은 CamelCase로, 폴더명은 소문자로 일관성 있게 사용해야 합니다.</li>
<li>공백, 언더바 및 특수문자는 파일명과 폴더명 모두에서 사용하지 않습니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="레이아웃-구성"><a class="header" href="#레이아웃-구성">레이아웃 구성</a></h2>
<h3 id="frame-layout"><a class="header" href="#frame-layout">Frame layout</a></h3>
<p>Frame 구조는 Header, LeftMenu, Contents Area 로 구성됩니다.
Navigation Type은 Top-Float-Only, Top-Only, Left-Only 의 기본 3가지가 있습니다.</p>
<p>기본 Nvation type 설정은 uiSettings.js 파일에서 수정할 수 있습니다.</p>
<pre><code class="language-javascript">defaultMenuType: 'floatMenu',// ['sideBarMenu','topMenu','floatMenu']
</code></pre>
<p><img src="chapter3/../images/framelayout.jpg" alt="frame_layout" />
<img src="chapter3/../images/navigation.jpg" alt="navigation" /></p>
<h3 id="content-area-layout"><a class="header" href="#content-area-layout">content area layout</a></h3>
<p><img src="chapter3/../images/contentlayout.jpg" alt="content_area_layout" /></p>
<h3 id="1-수직레이아웃"><a class="header" href="#1-수직레이아웃">1. 수직레이아웃</a></h3>
<p><strong>파일명:</strong>  <code>Sample01.jsx</code></p>
<h4 id="splitpanel"><a class="header" href="#splitpanel">SplitPanel</a></h4>
<blockquote>
<p>레이아웃을 수평/수직으로 분리하는 Component</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>속성 명</th><th style="text-align: center">값</th><th style="text-align: center">default</th><th>설명</th></tr></thead><tbody>
<tr><td>sizes</td><td style="text-align: center">[50, 50]</td><td style="text-align: center">[50, 50]</td><td>화면 비율. default: [50, 50], 합계가 100이 되게 배열로 구성</td></tr>
<tr><td>direction</td><td style="text-align: center"><code>vertical</code>, <code>horizontal</code></td><td style="text-align: center">vertical</td><td>방향</td></tr>
</tbody></table>
</div>
<h4 id="hlayoutbox"><a class="header" href="#hlayoutbox">HLayoutBox</a></h4>
<blockquote>
<p>수평 레이아웃을 구성하는 박스</p>
</blockquote>
<pre><code class="language-jsx">import React, { useState, useEffect } from "react";
import {
  ContentInner, SearchArea, WorkArea, ResultArea, ButtonArea, LeftButtonArea, RightButtonArea, SearchRow,
  InputField, BaseGrid, GridAddRowButton, GridDeleteRowButton, GridSaveButton, useContentStore,
  useIconStyles, useViewStore, zAxios,
  SplitPanel, HLayoutBox, VLayoutBox
} from "@wingui/common/imports";

function Sample01() {
  return (
    &lt;ContentInner&gt;
      &lt;SearchArea&gt;
        &lt;SearchRow&gt;
          Search 영역
        &lt;/SearchRow&gt;
      &lt;/SearchArea&gt;
      &lt;WorkArea&gt;
        &lt;SplitPanel sizes={[60, 40]} &gt;
          &lt;HLayoutBox&gt;
            Top Contents
          &lt;/HLayoutBox&gt;
          &lt;HLayoutBox&gt;
            Bottom Contents
          &lt;/HLayoutBox&gt;
        &lt;/SplitPanel&gt;
      &lt;/WorkArea&gt;
  &lt;/ContentInner&gt;
  );
}


export default Sample01
</code></pre>
<h3 id="2-수평-레이아웃"><a class="header" href="#2-수평-레이아웃">2. 수평 레이아웃</a></h3>
<p><strong>파일명:</strong>  <code>Sample02.jsx</code></p>
<h4 id="vlayoutbox"><a class="header" href="#vlayoutbox">VLayoutBox</a></h4>
<blockquote>
<p>수직 레이아웃을 구성하는 박스</p>
</blockquote>
<pre><code class="language-jsx">// Sample02.jsx
import React, { useState, useEffect } from "react";
import {
  ContentInner, SearchArea, WorkArea, ResultArea, ButtonArea, LeftButtonArea, RightButtonArea, SearchRow,
  InputField, BaseGrid, GridAddRowButton, GridDeleteRowButton, GridSaveButton, useContentStore,
  useIconStyles, useViewStore, zAxios,
  SplitPanel, VLayoutBox 
} from "@wingui/common/imports";

function Sample02() {
  return (
    &lt;ContentInner&gt;
      &lt;SearchArea&gt;
        &lt;SearchRow&gt;
          Search 영역
        &lt;/SearchRow&gt;
      &lt;/SearchArea&gt;
      &lt;WorkArea&gt;
        &lt;SplitPanel sizes={[60, 40]} direction={"horizontal"}&gt;
          &lt;VLayoutBox&gt;
            Left Contents
          &lt;/VLayoutBox&gt;
          &lt;VLayoutBox&gt;
            Right Contents
          &lt;/VLayoutBox&gt;
        &lt;/SplitPanel&gt;
      &lt;/WorkArea&gt;
  &lt;/ContentInner&gt;
  );
}


export default Sample02
</code></pre>
<h3 id="3-복합-레이아웃"><a class="header" href="#3-복합-레이아웃">3. 복합 레이아웃</a></h3>
<p><strong>파일명:</strong>  <code>Sample03.jsx</code></p>
<pre><code class="language-jsx">import React, { useState, useEffect } from "react";
import {
  ContentInner, SearchArea, WorkArea, ResultArea, ButtonArea, LeftButtonArea, RightButtonArea, SearchRow,
  InputField, BaseGrid, GridAddRowButton, GridDeleteRowButton, GridSaveButton, useContentStore,
  useIconStyles, useViewStore, zAxios,
  SplitPanel, HLayoutBox, VLayoutBox
} from "@wingui/common/imports";

function Sample03() {
  return (
    &lt;ContentInner&gt;
      &lt;SearchArea&gt;
        &lt;SearchRow&gt;
          Search 영역
        &lt;/SearchRow&gt;
      &lt;/SearchArea&gt;
      &lt;WorkArea&gt;
        &lt;SplitPanel&gt;
          &lt;HLayoutBox&gt;
            &lt;SplitPanel sizes={[40, 30, 30]} direction={"horizontal"}&gt;
              &lt;VLayoutBox&gt;
                Top Left
              &lt;/VLayoutBox&gt;
              &lt;VLayoutBox&gt;
                Top Middle
              &lt;/VLayoutBox&gt;
              &lt;VLayoutBox&gt;
                Top Right
              &lt;/VLayoutBox&gt;
            &lt;/SplitPanel&gt;
          &lt;/HLayoutBox&gt;
          &lt;HLayoutBox&gt;
            Bottom Contents
          &lt;/HLayoutBox&gt;
        &lt;/SplitPanel&gt;
      &lt;/WorkArea&gt;
  &lt;/ContentInner&gt;
  );
}


export default Sample03
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="inputs"><a class="header" href="#inputs">Inputs</a></h2>
<blockquote>
<p>솔루션에서 사용하는 다양한 input 스타일들을 모아 놓았습니다.</p>
</blockquote>
<p><strong>파일명:</strong>  <code>Sample06.jsx</code></p>
<ul>
<li>type : text, number, select, multiSelect, autocomplete, check, radio, datetime, time, dataeRange, popover, action, custom</li>
</ul>
<h3 id="input-type"><a class="header" href="#input-type">input type</a></h3>
<h4 id="1-text-텍스트-입력-text-input"><a class="header" href="#1-text-텍스트-입력-text-input">1. text: <strong>텍스트 입력 (Text Input)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 기본적인 텍스트 입력 필드로, 사용자가 문자열을 입력할 수 있습니다.</li>
</ul>
<h4 id="2-number-숫자-입력-number-input"><a class="header" href="#2-number-숫자-입력-number-input">2. number: <strong>숫자 입력 (Number Input)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 숫자를 입력받는 필드로, 숫자 데이터를 처리할 때 사용됩니다.</li>
</ul>
<h4 id="3-action-액션-버튼-action-button"><a class="header" href="#3-action-액션-버튼-action-button">3. action: <strong>액션 버튼 (Action Button)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 입력 필드에 버튼을 포함하여 특정 작업을 실행할 수 있는 필드입니다.</li>
</ul>
<h4 id="4-select-선택-입력-select-input"><a class="header" href="#4-select-선택-입력-select-input">4. select: <strong>선택 입력 (Select Input)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 드롭다운 메뉴를 통해 여러 옵션 중 하나를 선택할 수 있는 필드입니다. 특정 옵션에 색을 표시하는 등의 <code>스타일 추가</code>가 필요할때는 class 를 통해 제어할 수 있습니다. (샘플에 구현 되어있음)</li>
</ul>
<h4 id="5-autocomplete-자동-완성-입력-autocomplete"><a class="header" href="#5-autocomplete-자동-완성-입력-autocomplete">5. autocomplete: <strong>자동 완성 입력 (AutoComplete)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 사용자가 입력을 시작하면 추천 옵션을 제공하는 입력 필드입니다.</li>
</ul>
<h4 id="6-multiselect-다중-선택-입력-multiselect"><a class="header" href="#6-multiselect-다중-선택-입력-multiselect">6. multiSelect: <strong>다중 선택 입력 (MultiSelect)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 여러 개의 항목을 동시에 선택할 수 있는 필드입니다. value 값이 배열 형태 입니다.</li>
<li>props
<ul>
<li>max: 선택 갯수 제한</li>
</ul>
</li>
</ul>
<h4 id="7-datetime-daterange-time-날짜-및-시간-입력-datetime-daterange"><a class="header" href="#7-datetime-daterange-time-날짜-및-시간-입력-datetime-daterange">7. datetime, daterange, time: <strong>날짜 및 시간 입력 (DateTime, DateRange)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 날짜, 시간 또는 날짜 범위를 선택할 수 있는 입력 필드입니다.</li>
</ul>
<h4 id="8-check-체크박스-입력-checkbox"><a class="header" href="#8-check-체크박스-입력-checkbox">8. check: <strong>체크박스 입력 (Checkbox)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 여러 개의 옵션 중 원하는 항목을 선택할 수 있는 체크박스 형태의 필드입니다.</li>
</ul>
<h4 id="9-radio-라디오-버튼-입력-radio-button"><a class="header" href="#9-radio-라디오-버튼-입력-radio-button">9. radio: <strong>라디오 버튼 입력 (Radio Button)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 여러 개의 옵션 중 하나만 선택할 수 있는 라디오 버튼 형태의 필드입니다.</li>
</ul>
<h4 id="10-popover-팝오버-입력-popover-input"><a class="header" href="#10-popover-팝오버-입력-popover-input">10. popover: <strong>팝오버 입력 (Popover Input)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 팝업 창을 통해 추가적인 입력 또는 선택을 할 수 있는 필드입니다.</li>
</ul>
<h4 id="11-레이블-텍스트-입력-labeltext"><a class="header" href="#11-레이블-텍스트-입력-labeltext">11. <strong>레이블 텍스트 입력 (LabelText)</strong></a></h4>
<ul>
<li><strong>설명</strong>: 레이블과 함께 텍스트 또는 다른 타입의 입력을 받을 수 있는 필드입니다. 표준 스타일은 아니지만 필요한 경우 사용할 수 있습니다.</li>
</ul>
<hr />
<p><strong>속성</strong> :</p>
<ul>
<li>
<p><code>name</code>: 폼 필드의 이름.</p>
</li>
<li>
<p><code>label</code>: 필드 레이블 텍스트.</p>
</li>
<li>
<p><code>control</code>: <code>react-hook-form</code>의 <code>control</code> 객체.</p>
</li>
<li>
<p><code>value</code>: 초기값 설정.</p>
</li>
<li>
<p><code>dateformat</code>: 날짜 포맷 지정.</p>
</li>
<li>
<p><code>options</code>: 선택 가능한 옵션 배열.</p>
</li>
<li>
<p><code>startAdornment</code>: 필드 앞에 붙는 텍스트 또는 기호.</p>
</li>
<li>
<p><code>childComponent</code>: 팝업 내에 렌더링할 컴포넌트.</p>
</li>
<li>
<p><code>readOnly</code>: true 로 설정시 입력 필드를 읽기 전용으로 설정.</p>
</li>
<li>
<p><code>disabled</code>: true 로 설정시 입력 필드를 비활성화 상태로 설정. 기본 HTML의 disabled 속성과 달리, react-hook-form에서는 비활성화된 필드의 값도 폼 제출 시 포함됨.</p>
</li>
<li>
<p><code>validationText</code>: 유효성 검사 시 표시할 메시지.</p>
</li>
<li>
<p><code>rules</code>: 유효성 검사 규칙 설정.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="탭"><a class="header" href="#탭">탭</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Sample05.jsx</code></p>
<h3 id="tabcontainer"><a class="header" href="#tabcontainer">TabContainer</a></h3>
<blockquote>
<p>탭을 감싸는 container. <br/>
Childrens 는 id를 key 값으로 구분함</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>속성 명</th><th style="text-align: center">값</th><th style="text-align: center">default</th><th>설명</th></tr></thead><tbody>
<tr><td>value</td><td style="text-align: center"></td><td style="text-align: center"></td><td></td></tr>
<tr><td>onChange</td><td style="text-align: center"></td><td style="text-align: center"></td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-jsx">import React, { useState, useEffect } from "react";
import {
  ContentInner, SearchArea, WorkArea, ResultArea, ButtonArea, LeftButtonArea, RightButtonArea, SearchRow,
  InputField, BaseGrid, GridAddRowButton, GridDeleteRowButton, GridSaveButton, useContentStore,
  useIconStyles, useViewStore, zAxios,
  SplitPanel, HLayoutBox, VLayoutBox
} from "@wingui/common/imports";
import { TabContainer } from '@zionex/wingui-core/component/TabContainer';
import { Box } from "@mui/material";

function Sample04() {
  const [tabValue, setTabValue] = useState('tab1');
  const tabChange = (event, newValue) =&gt; {
    setTabValue(newValue);
  };

  return (
    &lt;ContentInner&gt;
      &lt;SearchArea&gt;
        &lt;SearchRow&gt;
          Search 영역
        &lt;/SearchRow&gt;
      &lt;/SearchArea&gt;
      &lt;WorkArea&gt;
        &lt;TabContainer value={tabValue} onChange={tabChange}&gt;
          &lt;Box id="tab1"&gt;Tab1&lt;/Box&gt;
          &lt;Box id="tab2"&gt;Tab2&lt;/Box&gt;
          &lt;Box id="tab3"&gt;Tab3&lt;/Box&gt;
        &lt;/TabContainer&gt;
      &lt;/WorkArea&gt;
  &lt;/ContentInner&gt;
  );
}


export default Sample04
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="inputs-1"><a class="header" href="#inputs-1">Inputs</a></h2>
<p><strong>파일명:</strong>  <code>Sample07.jsx</code></p>
<p><strong>위젯 file path</strong> :  <code>\packages\wingui\src\view\widgets\</code> 아래에 위치
<strong>위젯 설정</strong> : 설정&gt;레이아웃&gt;위젯</p>
<h3 id="1-대시보드-위젯-개요"><a class="header" href="#1-대시보드-위젯-개요">1. 대시보드 위젯 개요</a></h3>
<p>DashboardPanel은 대시보드를 구성하는 주요 컴포넌트로, 여러 개의 위젯을 배치하고 사용자가 이를 통해 다양한 정보를 확인할 수 있게 해줍니다. 이 컴포넌트를 통해 대시보드의 레이아웃, 위젯의 크기와 위치, 그리고 대시보드의 동작을 제어할 수 있습니다.</p>
<p>대시보드는 여러 위젯을 배치하여 사용자에게 필요한 정보를 시각적으로 제공하는 UI 구성 요소입니다. 이 예제에서는 위젯 리스트를 JavaScript 객체 배열로 정의하여, 대시보드에 표시할 위젯들을 설정하고 있습니다.</p>
<h3 id="2-dashboardpanel-속성-설명"><a class="header" href="#2-dashboardpanel-속성-설명">2. <code>DashboardPanel</code> 속성 설명</a></h3>
<h4 id="21-actionbar"><a class="header" href="#21-actionbar">2.1 <strong>actionBar</strong></a></h4>
<ul>
<li>
<p><strong>설명</strong> : 대시보드의 상단에 액션 바(버튼이나 메뉴 같은 추가 동작을 위한 UI 요소)를 표시할지 여부를 결정합니다.</p>
</li>
<li>
<p><strong>타입</strong> : <code>boolean</code></p>
</li>
</ul>
<h4 id="22-fitheight"><a class="header" href="#22-fitheight">2.2 <strong>fitHeight</strong></a></h4>
<ul>
<li>
<p><strong>설명</strong> : 대시보드의 높이를 자동으로 조정할지 여부를 결정합니다. <code>true</code>로 설정하면 대시보드가 내용에 맞게 높이를 자동으로 조정합니다.</p>
</li>
<li>
<p><strong>타입</strong> : <code>boolean</code></p>
</li>
<li>
<p><strong>예시</strong> : <code>fitHeight={false}</code>는 고정된 높이를 유지함을 의미합니다.</p>
</li>
</ul>
<h4 id="23-isresizable"><a class="header" href="#23-isresizable">2.3 <strong>isResizable</strong></a></h4>
<ul>
<li>
<p><strong>설명</strong> : 사용자가 위젯의 크기를 조정할 수 있는지 여부를 결정합니다.</p>
</li>
<li>
<p><strong>타입</strong> : <code>boolean</code></p>
</li>
<li>
<p><strong>예시</strong> : <code>isResizable={false}</code>는 사용자가 위젯 크기를 조정할 수 없음을 의미합니다.</p>
</li>
</ul>
<h4 id="24-isdraggable"><a class="header" href="#24-isdraggable">2.4 <strong>isDraggable</strong></a></h4>
<ul>
<li>
<p><strong>설명</strong> : 사용자가 위젯을 드래그하여 위치를 변경할 수 있는지 여부를 결정합니다.</p>
</li>
<li>
<p><strong>타입</strong> : <code>boolean</code></p>
</li>
<li>
<p><strong>예시</strong> : <code>isDraggable={false}</code>는 사용자가 위젯을 드래그할 수 없음을 의미합니다.</p>
</li>
</ul>
<h4 id="25-title"><a class="header" href="#25-title">2.5 <strong>title</strong></a></h4>
<ul>
<li>
<p><strong>설명</strong> : 대시보드의 제목을 설정합니다. 빈 문자열로 설정하면 제목이 표시되지 않습니다.</p>
</li>
<li>
<p><strong>타입</strong> : <code>string</code></p>
</li>
<li>
<p><strong>예시</strong> : <code>title={""}</code>는 제목이 없는 대시보드를 의미합니다.</p>
</li>
</ul>
<h4 id="26-option"><a class="header" href="#26-option">2.6 <strong>option</strong></a></h4>
<ul>
<li>
<p><strong>설명</strong> : 대시보드의 추가 옵션을 설정합니다. 예제에서는 <code>store</code>라는 옵션이 사용되고 있으며, 대시보드의 특정 설정이나 데이터 소스를 지정하는 데 사용될 수 있습니다.</p>
</li>
<li>
<p><strong>타입</strong> : <code>object</code></p>
</li>
<li>
<p><strong>예시</strong> : <code>option={{ store: "PMG" }}</code>는 "PMG"라는 값을 <code>store</code> 옵션으로 전달합니다.</p>
</li>
</ul>
<h4 id="27-id"><a class="header" href="#27-id">2.7 <strong>id</strong></a></h4>
<ul>
<li>
<p><strong>설명</strong> : 대시보드의 고유 ID를 설정합니다. 이 ID는 대시보드를 식별하거나 관련 데이터를 불러오는 데 사용됩니다.</p>
</li>
<li>
<p><strong>타입</strong> : <code>string</code></p>
</li>
<li>
<p><strong>예시</strong> : <code>id={"Executive_Dashboard"}</code>는 "Executive_Dashboard"라는 ID를 가진 대시보드를 의미합니다.</p>
</li>
</ul>
<h4 id="28-widgets"><a class="header" href="#28-widgets">2.8 <strong>widgets</strong></a></h4>
<ul>
<li>
<p><strong>설명</strong> : 대시보드에 표시될 위젯의 리스트를 설정합니다. 여기서는 <code>makeWidgetPanel()</code> 함수가 위젯 리스트를 생성하여 반환합니다.</p>
</li>
<li>
<p><strong>타입</strong> : <code>array</code></p>
</li>
<li>
<p><strong>예시</strong> : <code>widgets={makeWidgetPanel()}</code>는 <code>makeWidgetPanel</code> 함수에서 생성된 위젯 리스트를 대시보드에 전달합니다.</p>
</li>
</ul>
<h4 id="29-ongetwidgets"><a class="header" href="#29-ongetwidgets">2.9 <strong>OnGetWidgets</strong></a></h4>
<ul>
<li>
<p><strong>설명</strong> : 위젯을 가져오거나 초기화할 때 호출되는 함수입니다. 대시보드가 초기화될 때 이 함수가 호출되어 위젯을 로드할 수 있습니다.</p>
</li>
<li>
<p><strong>타입</strong> : <code>function</code></p>
</li>
<li>
<p><strong>예시</strong> : <code>OnGetWidgets={OnGetWidgets}</code>는 <code>OnGetWidgets</code> 함수를 대시보드에 전달합니다.</p>
</li>
</ul>
<h3 id="3-위젯-리스트-구조"><a class="header" href="#3-위젯-리스트-구조">3. 위젯 리스트 구조</a></h3>
<pre><code class="language-javascript">let widgets = [
  {
    "key": "1",
    "title": transLangKey("TITEL01"),
    "widgetId": "WI_SAMPLE_01",
    "data-grid": {"w": 2, "h": 44, "x": 0, "y": 0},
    "showTitleBar": false,
  },
  // 다른 위젯들...
];
</code></pre>
<ul>
<li>
<p>key: 위젯의 고유 식별자입니다. 이 값은 리스트 내에서 위젯을 구분하는 데 사용됩니다.</p>
</li>
<li>
<p>title: 위젯의 제목을 나타냅니다. transLangKey 함수를 사용하여 다국어 지원을 할 수 있습니다.</p>
</li>
<li>
<p>widgetId: 위젯의 고유 ID를 나타냅니다.</p>
</li>
<li>
<p>data-grid: 위젯의 레이아웃 위치와 크기를 정의하는 속성입니다. 대시보드 레이아웃 시스템(예: react-grid-layout)에서 사용됩니다.</p>
</li>
</ul>
<pre><code>- 가로 9 x 세로 16
- w: 위젯의 너비를 정의합니다.
- h: 위젯의 높이를 정의합니다.
- x: 위젯의 수평 위치(열)를 정의합니다.
- y: 위젯의 수직 위치(행)를 정의합니다.
</code></pre>
<ul>
<li>showTitleBar: 위젯의 제목 표시줄을 표시할지 여부를 결정합니다. true일 경우 제목 표시줄이 보이고, false일 경우 숨겨집니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="theme"><a class="header" href="#theme">theme</a></h2>
<ul>
<li><a href="https://docs.google.com/presentation/d/1jNbdpCT4SzpADrHHW1jf5FOTHdXvbLfkkE5wJoZCH9k/edit#slide=id.g2ae73ed998f_0_17">테마 기능 가이드</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="메뉴생성-및-연결"><a class="header" href="#메뉴생성-및-연결">메뉴생성 및 연결</a></h2>
<ul>
<li>연관 DB: TB_AD_MENU</li>
<li>메뉴생성 및 수정 : 설정 &gt; 레이아웃 &gt; 메뉴관리 우측 마우스 클릭</li>
<li>하위 메뉴 추가 : 하위 메뉴 Path 추가. 반드시 path 에 해당하는 화면이 있어야 함</li>
<li>화면 추가 : 메뉴 추가</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>항목</th><th>설명</th></tr></thead><tbody>
<tr><td>메뉴 ID</td><td>키 값: 하위 메뉴 추가일 경우 접두사 <code>MENU_</code>, 화면 추가일 경우 접두사 <code>UI_</code></td></tr>
<tr><td>메뉴 Path</td><td>상위 메뉴 Path + "/" + 메뉴 path = url 경로</td></tr>
<tr><td>화면 파일 경로</td><td>(packages\wingui\src\view) <code>하위폴더구조</code>+/+파일명 (파일명이 속한 디렉터리는 생략)  <br/> ex)/fp/master/Item  -&gt;   packages\wingui\src\view\fp\master\item\Item.jsx</td></tr>
<tr><td>메뉴 seq</td><td>메뉴 순서</td></tr>
</tbody></table>
</div>
<ul>
<li><a href="chapter4/../chapter2/%ED%8C%8C%EC%9D%BC%EB%B0%8F%ED%8F%B4%EB%8D%94%EA%B5%AC%EC%A1%B0%EA%B0%80%EC%9D%B4%EB%93%9C%EB%9D%BC%EC%9D%B8.html">파일 및 폴더 네이밍 규칙</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="그리드-생성-및-data-load"><a class="header" href="#그리드-생성-및-data-load">그리드 생성 및 data load</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Practice01.jsx</code></p>
<blockquote>
<p>이 샘플에서는 화면 및 그리드 기본 구성, 배열 과 DB 프로시저를 호출하여 콤보박스를 구성할 수 있습니다.</p>
</blockquote>
<h3 id="그리드-컬럼-정의"><a class="header" href="#그리드-컬럼-정의"><strong>그리드 컬럼 정의</strong></a></h3>
<pre><code class="language-javascript">let grid1Items = [
  {name: "KORNAME", dataType: "text", headerText: "KORNAME", visible: true, editable: false, width: 100},
  {name: "GENDER", dataType: "text", headerText: "GENDER", visible: true, editable: true, width: 100, useDropdown: true, lookupDisplay: true},
  {name: "AGE", dataType: "number", headerText: "AGE", visible: true, editable: true, width: 100},
  {name: "PHONE", dataType: "text", headerText: "PHONE", visible: true, editable: true, width: 100},
  {name: "PRODUCTID", dataType: "text", headerText: "PRODUCTID", visible: false, editable: true, width: 100},
  {name: "KORCOUNTRY", dataType: "text", headerText: "KORCOUNTRY", visible: false, editable: true, width: 100},
  {name: "ORDERDATE", dataType: "datetime", headerText: "ORDERDATE", visible: true, editable: true, width: 100, format: "yyyy-MM-dd"},
  {name: "ACTIVE", dataType: "boolean", headerText: "ACTIVE", visible: true, editable: true, width: 100},
];
</code></pre>
<p><code>grid1Items</code>는 그리드의 컬럼을 정의합니다. 각 컬럼은 <code>name</code>, <code>dataType</code>, <code>headerText</code>, <code>visible</code>, <code>editable</code>, <code>width</code>, <code>autoFilter</code>, <code>editableNew</code>, <code>textAlignment</code>  등의 속성을 가집니다.</p>
<ul>
<li>name: 컬럼명</li>
<li>dataType: 자료형 (text, number, boolean, datetime 중 하나)</li>
<li>headerText: 헤더명. 다국어코드 입력시 자동 변환</li>
<li>visible: 표시 여부</li>
<li>editable: 수정 여부</li>
<li>width: 너비</li>
<li>autoFilter: type - boolean. 자동 필터 설정 여부</li>
<li>textAlignment: 정렬. left, right, center</li>
<li><code>editableNew</code>: type - boolean. 신규 입력만 가능. (수정 불가)</li>
</ul>
<h3 id="상태-및-훅-설정"><a class="header" href="#상태-및-훅-설정">상태 및 훅 설정</a></h3>
<pre><code class="language-javascript">function Practice01() {
  const activeViewId = getActiveViewId();
  const [viewData, getViewInfo, setViewInfo] = useViewStore((state) =&gt; [state.viewData, state.getViewInfo, state.setViewInfo]);
  const [genderOption, setGenderOption] = useState([]);
  const [grid1, setGrid1] = useState(null);

  const { control, getValues, setValue, watch, reset } = useForm({
    defaultValues: {
      plantCd: [],
      startDt: new Date(),
    },
  });

  const globalButtons = [
    { name: 'search', action: (e) =&gt; { loadData() }, visible: true, disable: false },
    { name: "refresh", action: (e) =&gt; { refresh() }, visible: true, disable: false },
  ];
</code></pre>
<ul>
<li>
<p><code>useState</code>를 사용하여 성별 옵션, 그리드 객체(<code>grid1</code>)와 같은 상태를 관리합니다.</p>
</li>
<li>
<p><code>useForm</code>을 사용해 폼 필드를 관리합니다. (react-hook-form)</p>
<ul>
<li>defaultValues : input default 값 설정</li>
</ul>
</li>
<li>
<p><code>globalButtons</code>는 상단의 전역 버튼을 정의</p>
</li>
</ul>
<h3 id="데이터-및-그리드-설정-관련-useeffect"><a class="header" href="#데이터-및-그리드-설정-관련-useeffect">데이터 및 그리드 설정 관련 <code>useEffect</code></a></h3>
<p>useEffect 함수는 리액트 컴포넌트가 렌더링 될때마다 특정 작업을 실행할 수 있도록 하는 Hook 이다. useEffect는 comopnent 가 mount 됐을때 , unmount 됐을때, update 됐을때 특정 작업을 처리할 수 있다.</p>
<blockquote>
<p>기본형태 : useEffection  ( fuction, deps )</p>
</blockquote>
<ul>
<li>fuction: 이 함수는 컴포넌트가 렌더링된 이후에 실행되며, 이 안에서 부작용을 처리할 수 있습니다.</li>
<li>의존성 배열 (Dependency Array): 이 배열에 나열된 값이 변경될 때마다 effect 함수가 실행된다. 의존성 배열이 비어있으면([]), function은 컴포넌트가 처음 렌더링될 때 한 번만 실행된다.</li>
</ul>
<pre><code class="language-javascript">  //초기 렌더링 시 데이터 가져오기
  useEffect(() =&gt; {
      loadCombo();
    }, []);

  //특정 상태가 변경될 때마다 실행
  useEffect(() =&gt; {
    setViewInfo(activeViewId, "globalButtons", globalButtons);
    
    if(grid1){
      loadGridCombo(); 
      loadData();
    }
  }, [grid1]);
</code></pre>
<ul>
<li>
<p>첫 번째 <code>useEffect</code>는 컴포넌트가 처음 렌더링될 때 <code>loadCombo</code>를 호출하여 성별 옵션을 불러옵니다.</p>
</li>
<li>
<p>두 번째 <code>useEffect</code>는 <code>grid1</code>이 설정될 때 그리드 콤보 박스 옵션을 설정하고 데이터를 불러옵니다.</p>
</li>
</ul>
<h3 id="데이터-로드-및-그리드-설정-함수"><a class="header" href="#데이터-로드-및-그리드-설정-함수">데이터 로드 및 그리드 설정 함수</a></h3>
<pre><code class="language-javascript">const loadCombo = async () =&gt; {
    const genderArr = [
      {label: "전체", value: "ALL"},
      {label: "남자", value: "남"},
      {label: "여자", value: "여"},
    ];

    setGenderOption(genderArr);
    setValue("gender", genderArr.length &gt; 0 ? genderArr[0].value : "");
  };

  const loadGridCombo = async () =&gt; {
    grid1.gridView.setColumnProperty(
      "GENDER",
      "lookupData",
      {
        value: "CODE",
        label: "NAME",
        list: [
          {NAME: "전체", CODE: "ALL"},
          {NAME: "남자", CODE: "남"},
          {NAME: "여자", CODE: "여"},
        ]
      }
    );
  };

  const loadData = () =&gt; {
    let data = [
      // 실제 데이터 목록
    ];
     
    grid1.dataProvider.fillJsonData(data);
  };
</code></pre>
<ul>
<li>
<p><code>loadCombo</code>는 성별 옵션을 불러와 <code>genderOption</code> 상태를 업데이트하고 기본 값을 설정합니다.</p>
</li>
<li>
<p><code>loadGridCombo</code>는 그리드 내의 성별 컬럼에 콤보 박스 데이터를 설정합니다.</p>
</li>
<li>
<p><code>loadData</code>는 데이터를 그리드에 채웁니다. Sample01 에서는 하드코딩된 데이터를 사용합니다.</p>
</li>
</ul>
<h3 id="기타-기능-함수"><a class="header" href="#기타-기능-함수">기타 기능 함수</a></h3>
<pre><code class="language-javascript">const refresh = () =&gt; {
    grid1.gridView.refresh();
    grid1.dataProvider.clearRows();
    reset();
    loadCombo();
  };

  const afterGrid1Create = (gridObj, gridView, dataProvider) =&gt; {
    gridView.setDisplayOptions({ fitStyle: 'even' });
    setVisibleProps(gridObj, true, true, true);
    setGrid1(gridObj);
  };

  function saveData() {
    console.log("saveData");
  }  

  function deleteData(targetGrid, deleteRows) {
    if (deleteRows.length &gt; 0) {
      console.log("deleteData");
    }
  }
</code></pre>
<ul>
<li>
<p><code>refresh</code>는 그리드를 새로 고치고 폼을 초기화합니다.</p>
</li>
<li>
<p><code>afterGrid1Create</code>는 그리드가 생성된 후 호출되며, 그리드의 설정을 적용하고 <code>grid1</code> 상태를 업데이트합니다.</p>
</li>
<li>
<p><code>saveData</code>와 <code>deleteData</code>는 데이터 저장 및 삭제를 위한 함수입니다.</p>
</li>
</ul>
<h3 id="ui-구성"><a class="header" href="#ui-구성">UI 구성</a></h3>
<pre><code class="language-jsx">return (
    &lt;ContentInner&gt;
      &lt;SearchArea&gt;
        &lt;InputField type="select" name="gender" control={control} label={transLangKey('GENDER')} options={genderOption} /&gt;
        &lt;InputField type="datetime" name="startDt" control={control} label={transLangKey('START_DT')} dateformat="yyyy-MM-dd"/&gt;
      &lt;/SearchArea&gt;
      &lt;WorkArea&gt;
        &lt;ButtonArea&gt;
          &lt;LeftButtonArea&gt;
          &lt;/LeftButtonArea&gt;
          &lt;RightButtonArea&gt;
            &lt;GridAddRowButton grid="grid1"&gt;&lt;/GridAddRowButton&gt;
            &lt;GridDeleteRowButton grid="grid1" onDelete={deleteData}&gt;&lt;/GridDeleteRowButton&gt;
            &lt;GridSaveButton grid="grid1" onClick={saveData} /&gt;
          &lt;/RightButtonArea&gt;
        &lt;/ButtonArea&gt;
        &lt;ResultArea&gt;
          &lt;Box style={{ height: "100%" }}&gt;
            &lt;BaseGrid id="grid1" items={grid1Items} afterGridCreate={afterGrid1Create} /&gt;
          &lt;/Box&gt;
        &lt;/ResultArea&gt;
      &lt;/WorkArea&gt;
    &lt;/ContentInner&gt;
  );
}
</code></pre>
<ul>
<li>
<p>이 부분은 실제 UI를 구성하는 코드입니다.</p>
</li>
<li>
<p>크게 검색 영역(<code>SearchArea</code>), 작업 영역(<code>WorkArea</code>) 으로 구성되고, 작업 영역은 버튼 영역(<code>ButtonArea</code>), 결과 영역(<code>ResultArea</code>)으로 구성됩니다.</p>
</li>
<li>
<p>그리드 관련 버튼 : <code>GridAddRowButton</code>, <code>GridDeleteRowButton</code>, <code>GridSaveButton</code></p>
</li>
</ul>
<h3 id="search-combo-구성"><a class="header" href="#search-combo-구성">search combo 구성</a></h3>
<h4 id="배열-데이터로-구성"><a class="header" href="#배열-데이터로-구성">배열 데이터로 구성</a></h4>
<pre><code class="language-jsx"> const genderArr = [
      {label: "전체", value: "ALL"},
      {label: "남자", value: "남"},
      {label: "여자", value: "여"},
    ]

    setGenderOption(genderArr);
    setValue("gender", genderArr.length &gt; 0 ? genderArr[0].value : "");

</code></pre>
<h4 id="db-procedure-호출"><a class="header" href="#db-procedure-호출">DB procedure 호출</a></h4>
<ul>
<li>dropdown 은 label, value 로 구성됩니다.</li>
<li>PROCEDURE_NAME : 호출할 프로시저 명</li>
<li>PARAM : 프로시저 파라미터 ( 프로시저에 따라 다르게 구성됨 )</li>
<li>CODE_KEY : value 로 설정할 코드</li>
<li>CODE_VALUE : label 로 설정할 코드</li>
</ul>
<pre><code class="language-jsx">    //db 호출
        //db 호출
    const moduleArr = await loadComboList({
      PROCEDURE_NAME: "SP_COMM_SRH_COMBO_LIST_Q",
      URL: "common/data",
      CODE_KEY: "CODE",
      CODE_VALUE: "NAME",
      PARAM: {
        P_CODE: "MODULE_TP", 
        P_ALL_GBN: "",
        P_ATTR1: "",
        P_ATTR2: "",
        P_ATTR3: "",
        P_ATTR4: "",
        P_ATTR5: "",
      },
    });

    setModuleCdOption(moduleArr);
    setValue("module", moduleArr.length &gt; 0 ? moduleArr[0].value : "");
</code></pre>
<h3 id="grid-combo-구성"><a class="header" href="#grid-combo-구성">grid combo 구성</a></h3>
<h4 id="배열-데이터로-구성-1"><a class="header" href="#배열-데이터로-구성-1">배열 데이터로 구성</a></h4>
<pre><code class="language-jsx">grid1.gridView.setColumnProperty(
      "GENDER",
      "lookupData",
      {
        value: "CODE",
        label: "NAME",
        list: [
          {NAME: "전체", vaCODElue: "ALL"},
          {NAME: "남자", CODE: "남"},
          {NAME: "여자", CODE: "여"},
        ]
      }
    );
</code></pre>
<h4 id="db-procedure-호출-1"><a class="header" href="#db-procedure-호출-1">DB procedure 호출</a></h4>
<ul>
<li>dropdown 은 label, value 로 구성됩니다.</li>
<li>PROCEDURE_NAME : 호출할 프로시저 명</li>
<li>PARAM : 프로시저 파라미터 ( 프로시저에 따라 다르게 구성됨 )</li>
<li>CODE_VALUE : value 로 설정할 코드</li>
<li>CODE_LABEL : label 로 설정할 코드</li>
<li><code>PARAM_KEY</code>와 <code>PARAM_VALUE</code>는 각각 키(key)와 값(value)을 나타내는 배열입니다. 이 두 배열은 쌍(pair)으로 작동하며, 배열의 각 인덱스 위치가 서로 대응됩니다. 배열의 처음은 PROCEDURE_NAME 이 되어야하고 나머지 값들은 프로시저의 파라미터 값입니다.</li>
</ul>
<pre><code class="language-jsx">    await gridComboLoad(grid1, {
      URL: "common/data",
      CODE_VALUE: "CODE",
      CODE_LABEL: "NAME",
      COLUMN: "MODULE_CD",
      PROP: "lookupData",
      PARAM_KEY: ["PROCEDURE_NAME", "P_CODE"],
      PARAM_VALUE: ["SP_COMM_SRH_COMBO_LIST_Q", "MODULE_TP"],
      TRANSLANG_LABEL: false,
    });
</code></pre>
<hr />
<h3 id="컬럼-너비-자동-조정"><a class="header" href="#컬럼-너비-자동-조정">컬럼 너비 자동 조정</a></h3>
<p>컬럼 너비를 자동으로 조정하는 방법에 대한 설정 옵션입니다. 자세한 내용은 <a href="https://docs.realgrid.com/guides/column/grid-fitting">RealGrid 가이드</a> 를 참고하세요.</p>
<ul>
<li><strong>none</strong>
남는 영역에 대해 채우기를 하지 않습니다.</li>
</ul>
<pre><code class="language-javascript">gridView.displayOptions.fitStyle = "none";
</code></pre>
<ul>
<li><strong>even</strong>
컬럼 전체의 너비가 그리드 영역보다 작으면 각 컬럼의 너비를 <code>width</code> 속성값에 맞춰 그리드의 너비에 맞게 비례적으로 배분합니다.</li>
</ul>
<pre><code class="language-javascript">gridView.displayOptions.fitStyle = "even";
</code></pre>
<ul>
<li><strong>evenFill</strong>
컬럼 전체 너비와 상관없이 각 컬럼의 너비를 <code>width</code> 속성값에 맞춰 그리드의 너비에 맞게 비례적으로 항상 배분합니다.</li>
</ul>
<pre><code class="language-javascript">gridView.displayOptions.fitStyle = "evenFill";
</code></pre>
<ul>
<li><strong>fill</strong>
컬럼 전체의 너비가 그리드 영역보다 작으면 <code>fillWidth</code> 값이 0 이하인 컬럼은 손대지 않고, 0보다 큰 컬럼들을 <code>fillWidth</code> 비율대로 배분합니다. 아래 예제에서는 <code>"이름"</code>, <code>"성별"</code> 컬럼들만 <code>fillWidth</code> 값이 1로 설정되었습니다.</li>
</ul>
<pre><code class="language-javascript">gridView.displayOptions.fitStyle = "fill";
</code></pre>
<h3 id="even과-evenfill의-차이점"><a class="header" href="#even과-evenfill의-차이점">even과 evenFill의 차이점</a></h3>
<ul>
<li>
<p><strong>even</strong> :
컬럼 너비의 합이 그리드 너비보다 작은 경우에만 남는 영역에 대해 비례적으로 배분합니다.</p>
</li>
<li>
<p><strong>evenFill</strong> :
남는 영역의 여부와 상관없이 항상 비례적으로 배분합니다. 남아있는 영역이 있는 경우, <code>even</code>과 <code>evenFill</code>의 결과는 동일합니다.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="java-controller"><a class="header" href="#java-controller">Java controller</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Practice02.jsx</code>,<code>PracticeController.java</code></p>
<blockquote>
<p>이 샘플에서는 Java 컨트롤러에서 저장 프로시저(SP)와 SQL 쿼리문을 호출하는 방법을 실습해볼 수 있습니다. SQL 쿼리문 호출 시 반드시 PreparedStatement를 사용해야 합니다. 또한, queryHandler의 save 메서드는 P_RT_ROLLBACK_FLAG와 P_RT_MSG 두 가지 OUTPUT 파라미터를 기본으로 포함하고 있으므로, 저장 프로시저에서도 이를 구현해야 합니다.</p>
</blockquote>
<h3 id="실행권한-체크"><a class="header" href="#실행권한-체크">실행권한 체크</a></h3>
<ul>
<li>ExecPermission annotation 사용
<ul>
<li>menuCd: 화면 ID</li>
<li>type : 조회권한 타입 ( PERMISSION_TYPE_READ, PERMISSION_TYPE_UPDATE, PERMISSION_TYPE_DELETE )</li>
</ul>
</li>
</ul>
<h3 id="조회"><a class="header" href="#조회">조회</a></h3>
<pre><code class="language-java">    @ExecPermission(menuCd = "UI_PRACTICE_01", type = ServiceConstants.PERMISSION_TYPE_READ)
    @PostMapping("/practice/q1")
    public List&lt;Map&lt;String, Object&gt;&gt; getData1(@RequestBody Map&lt;String, Object&gt; params, HttpServletRequest request) throws Exception {
        return queryHandler.getList("SP_UI_PRACTICE_01Q", params);
    }
</code></pre>
<h3 id="저장"><a class="header" href="#저장">저장</a></h3>
<ul>
<li>commonService.saveData()를 호출하여 공통 서비스에서 예외 처리가 될 수 있게 함.</li>
</ul>
<pre><code class="language-java">    @ExecPermission(menuCd = "UI_PRACTICE_01", type = ServiceConstants.PERMISSION_TYPE_UPDATE)
    @PostMapping("/practice/s1")
    public Map&lt;String, Object&gt; saveData1(@RequestBody List&lt;Map&lt;String, Object&gt;&gt; changes, HttpServletRequest request) throws Exception {
        String username = userService.getUserDetails().getUsername();

        Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;();
        for (Map&lt;String, Object&gt; params : changes) {
            Map&lt;String, Object&gt; param = new HashMap&lt;&gt;();
            param.put("P_ID", new Object[] { params.get("ID"), String.class, ParameterMode.IN });
            param.put("P_KORNAME", new Object[] { params.get("KORNAME"), String.class, ParameterMode.IN });
            param.put("P_GENDER", new Object[] { params.get("GENDER"), String.class, ParameterMode.IN });
            param.put("P_AGE", new Object[] { params.get("AGE"), Integer.class, ParameterMode.IN });
            param.put("P_USERNAME", new Object[] { username, String.class, ParameterMode.IN });
            
            Map&lt;String, Object&gt; result = commonService.saveData("SP_UI_PRACTICE_01S", param);
            resultMap.putAll(result);
        }
        return resultMap;
    }
</code></pre>
<h3 id="삭제"><a class="header" href="#삭제">삭제</a></h3>
<pre><code class="language-java">    @ExecPermission(menuCd = "UI_PRACTICE_01", type = ServiceConstants.PERMISSION_TYPE_DELETE)
    @PostMapping("/practice/d1")
    public Map&lt;String, Object&gt; deleteData1(@RequestBody List&lt;Map&lt;String, Object&gt;&gt; changes, HttpServletRequest request) throws Exception {
        String username = userService.getUserDetails().getUsername();

        Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;();
        for (Map&lt;String, Object&gt; params : changes) {
            Map&lt;String, Object&gt; param = new HashMap&lt;&gt;();
            param.put("P_ID", new Object[] { params.get("ID"), String.class, ParameterMode.IN });
            param.put("P_USERNAME", new Object[] { username, String.class, ParameterMode.IN });
            
            Map&lt;String, Object&gt; result = commonService.saveData("SP_UI_PRACTICE_01D", param);
            resultMap.putAll(result);
        }
        return resultMap;
    }
</code></pre>
<h3 id="native-sql"><a class="header" href="#native-sql">native sql</a></h3>
<ul>
<li>sql 문을 직접 호출 할 수 있지만 프로시저 사용을 권장함.</li>
</ul>
<pre><code class="language-java">    @ExecPermission(menuCd = "UI_PRACTICE_01", type = ServiceConstants.PERMISSION_TYPE_READ)
    @PostMapping("/practice/q2")
    public List&lt;?&gt; getData2(@RequestBody Map&lt;String, Object&gt; params, HttpServletRequest request) throws Exception {
        String sqlQuery = "SELECT '쿼리-박OO' AS KORNAME, '남' AS GENDER, '71' AS AGE, '(025)6563-2802' AS PHONE, " +
                "'198160731-00008' AS PRODUCTID, '모잠비크' AS KORCOUNTRY, '2021-01-16' AS ORDERDATE, 'Y' AS ACTIVE " +
                "UNION ALL " +
                "SELECT '쿼리-조OO', '남', '62', '(093)8809-8696', " +
                "'571215854-00001', '캐나다', '2019-07-29', 'Y' " +
                "UNION ALL " +
                "SELECT '쿼리-김OO', '남', '45', '(010)1234-5678', " +
                "'123456789-00003', '한국', '2020-05-23', 'N' " +
                "UNION ALL " +
                "SELECT '쿼리-이OO', '여', '32', '(010)8765-4321', " +
                "'987654321-00004', '미국', '2020-11-11', 'Y' " +
                "UNION ALL " +
                "SELECT '쿼리-한OO', '여', '29', '(010)5555-6666', " +
                "'55556666-00005', '호주', '2021-03-14', 'Y' " +
                "UNION ALL " +
                "SELECT '쿼리-장OO', '남', '39', '(010)7777-8888', " +
                "'77778888-00006', '영국', '2018-09-17', 'N' " +
                "UNION ALL " +
                "SELECT '쿼리-송OO', '여', '35', '(010)9999-0000', " +
                "'99990000-00007', '프랑스', '2021-06-21', 'N';";

        return queryHandler.getNativeQueryData(sqlQuery);
    }

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="realgrid-event"><a class="header" href="#realgrid-event">realgrid event</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Practice03.jsx</code>, <code>Practice03.css</code></p>
<ul>
<li>개발자 도구를 키고 console 탭을 확인하면 그리드 동작 이벤트마다 console이 찍히는 것을 확인할 수 있습니다.</li>
<li>보통 Master Detail 구조의 grid 에서는 detail grid데이터를 master grid의  onCellClicked 이벤트로 구현합니다.</li>
<li><U>dataProvider 와 gridView 의 차이점을 반드시 아셔야합니다. 아래 링크를 꼭 확인해주세요. </U></li>
</ul>
<pre><code>dataRow = data 고유의 row id 
itemIndex = 화면에서 보이는 현재 id (정렬이나 필터에 따라 달라질 수 있음)
itemIndex ---------- gridView
dataRow ----------- dataProvider

# 올바른 사용법
dataProvider.getValue(index.dataRow, "컬럼명") 
gridView.getValue(index.itemIndex, "컬럼명")

# 틀린사용법
dataProvider.getValue(index.itemIndex, "컬럼명") (틀린 사용법)
gridView.getValue(index.dataRow, "컬럼명") (틀린 사용법)
</code></pre>
<pre><code>gridView.getCheckedItems() // 체크된 itemIndex 값 배열을 가져옴
gridView.getCheckedRows() // 체크된 dataRow값 배열을 가져옴
</code></pre>
<ul>
<li>
<p><a href="https://help.realgrid.com/tutorial/a11/">Data와 Item의 다른점</a></p>
</li>
<li>
<p><a href="https://docs.realgrid.com/guides/events/event-order">이벤트 발생 순서</a></p>
</li>
<li>
<p><a href="https://docs.realgrid.com/guides/events/click-event">클릭 이벤트</a></p>
</li>
<li>
<p><a href="https://docs.realgrid.com/guides/events/data-load-complete">렌더링 완료 이벤트</a></p>
</li>
<li>
<p><U>리얼 그리드 기능 자체에 대한 건 리얼 그리드 홈페이지 및 고객지원센터를 적극 활용하시면 됩니다.</U></p>
</li>
<li>
<p><a href="https://support.realgrid.com/">리얼그리드 고객지원</a></p>
</li>
</ul>
<h3 id="realgrid-stylecallback-이벤트와-css-설정"><a class="header" href="#realgrid-stylecallback-이벤트와-css-설정">realgrid styleCallback 이벤트와 css 설정</a></h3>
<ul>
<li>styleCallback: 스타일을 지정하기 위한 콜백
StyleCallback을 지정하면, 기본 스타일 외의 다른 스타일들이 초기화되어 스타일을 다시 지정해야 합니다. StyleCallback을 통해 지정하는 스타일은 클래스(class) 방식으로만 적용할 수 있습니다. React에서 클래스(class)를 지정할 때, CacheRoute 방식 때문에 다른 화면에 영향을 미칠 수 있으므로, CSS를 작성할 때 #화면아이디 .className {} 형태로 구성해야 합니다. css파일은 보통 화면파일명과 동일하게 설정합니다.
#화면아이디 는 #contentInner-activeViewId(메뉴ID) 입니다.</li>
</ul>
<pre><code class="language-css">#contentInner-UI_PRACTICE_03 .red {
  color: #fa0017;
}
</code></pre>
<ul>
<li>
<p>리얼 그리드의 기본 정렬은 <strong>가운데 정렬</strong> 입니다. 아래 설정들은 dataType 에 따라 정렬 설정을 해주기 위해 wingui 에서 커스텀으로 만든 class 입니다.</p>
<ul>
<li>
<p><strong>숫자:</strong> 오른쪽 정렬  <code>column-textAlign-far</code></p>
</li>
<li>
<p><strong>텍스트:</strong>  왼쪽 정렬 <code>column-textAlign-near</code></p>
</li>
<li>
<p><strong>수정 가능:</strong>  <code>editable-column</code></p>
</li>
</ul>
</li>
<li>
<p><U>리얼 그리드의 styleCallback 라는 기능을 사용하여 style class 를 추가할때 wingui 커스텀 class가 <code>초기화</code> 되므로 타입과 editable 여부에 따라 <code>재지정</code> 해줘야합니다.</U></p>
</li>
</ul>
<pre><code class="language-javascript">{name: "AGE", dataType: "number", headerText :"AGE" , visible: true, editable: true, width: 100,
    styleCallback: function (grid, dataCell) {
      let ret = {};
      let age = grid.getValue(dataCell.index.itemIndex, "AGE");
      if(age &gt; 40){
        ret.styleName = `${dataCell.dataColumn.styleName} red`;
        ret.editable = true;
      }else{
        ret.editable = false;
      }
      return ret;
    }
  }, 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="crud-샘플"><a class="header" href="#crud-샘플">CRUD 샘플</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Practice04.jsx</code>, <code>PraticeController.java</code></p>
<blockquote>
<p>이 샘플은 데이터베이스를 이용한 조회, 저장, 삭제 기능을 구현한 예제입니다. 개발 시, 이 구조를 참고하여 개발을 진행해 주세요.</p>
</blockquote>
<h3 id="crud-url-권장-네이밍-규칙"><a class="header" href="#crud-url-권장-네이밍-규칙">crud url 권장 네이밍 규칙</a></h3>
<p>화면에 여러 개의 그리드가 있을 경우, 각 그리드에 대해 URL을 구분하기 위해 q1, q2, q3 식으로 숫자를 증가시켜 사용합니다.</p>
<ul>
<li>조회 : 메뉴path/q1</li>
<li>저장 : 메뉴path/s1</li>
<li>삭제 : 메뉴path/d1</li>
<li>팝업 : 메뉴path/popup/q1</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pivot-grid"><a class="header" href="#pivot-grid">Pivot Grid</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Practice05.jsx</code>, <code>PracticeController.java</code></p>
<blockquote>
<p>이 샘플에서는 피벗 데이터를 가공하여 그리드 형태로 구현하는 방법을 보여줍니다.</p>
</blockquote>
<h3 id="backend"><a class="header" href="#backend">backend</a></h3>
<p><strong>1. 데이터 그룹화</strong> 이후, 스트림 API를 사용해 데이터를 <code>pivotColumns</code> 함수에서 정의한 기준에 따라 그룹화합니다. <code>Collectors.groupingBy</code>를 사용해 데이터를 그룹화하고, 각 그룹을 리스트로 반환합니다.</p>
<pre><code class="language-java">Collection&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; groupedList = dataList.stream()
    .collect(Collectors.groupingBy(pivotColumns, LinkedHashMap::new, Collectors.toList())).values();
</code></pre>
<p><strong>2. 헤더 추출</strong> 각 그룹의 데이터에서 <code>PLAN_DATE</code> 필드를 기준으로 헤더를 추출합니다. 이 헤더는 피벗 테이블에서 컬럼 헤더로 사용됩니다. 추출된 헤더는 <code>TreeSet</code>을 사용해 중복을 제거하고 정렬합니다.</p>
<pre><code class="language-java">Set&lt;String&gt; header = new TreeSet&lt;&gt;();
for (Map&lt;String, Object&gt; heads : dataList) {
  header.add((String) heads.get("PLAN_DATE"));
}
</code></pre>
<p><strong>3-1. 피벗 데이터 구성</strong> 그룹화된 각 데이터를 순회하며, 헤더에 맞게 데이터를 재배치합니다. 그룹 내 각 데이터의 <code>PLAN_DATE</code>를 기준으로 <code>QTY</code> 값을 배열에 배치하고, 이를 다시 맵에 추가합니다.</p>
<pre><code class="language-java">if (header.size() &gt; 0) {
  String[] existDataHeader = header.toArray(new String[header.size()]);
  for (List&lt;Map&lt;String, Object&gt;&gt; groupItem : groupedList) {
    Object[] qty = new Object[existDataHeader.length];
    boolean existDataFlag = false;

    for (Map&lt;String, Object&gt; item : groupItem) {
      String headerIdx = (String) item.get("PLAN_DATE");
      int idx = Arrays.asList(existDataHeader).indexOf(headerIdx);
      qty[idx] = item.get("QTY");
      existDataFlag = true;
    }
    if (existDataFlag) {
      Map&lt;String, Object&gt; item = groupItem.get(0);
      item.put("QTY", Arrays.asList(qty));
      data.add(item);
    }
  }
  resultMap.put("header", header);
  resultMap.put("data", data);
} else {
  resultMap.put("header", null);
  resultMap.put("data", dataList);
}
</code></pre>
<p>이 과정에서 <code>existDataFlag</code>는 데이터가 유효한지 확인하는 플래그로 사용되며, 유효한 경우에만 피벗 데이터가 추가됩니다.</p>
<p><strong>3-2. PivotUtil.java 사용</strong></p>
<p>주어진 입력값들을 기준으로 Grouping을 하고, 그 결과를 피벗 테이블로 변환하여 리턴.</p>
<p><strong>파라미터 설명</strong>
<u>배열로 들어가는 값들은 모두 DB 컬럼명</u>이다.</p>
<div class="table-wrapper"><table><thead><tr><th>파라미터명</th><th style="text-align: center">설명</th><th style="text-align: center">예시</th></tr></thead><tbody>
<tr><td>dataList</td><td style="text-align: center"></td><td style="text-align: center">[{"PLANT_ID": "P1", "QTY": 100}, ...]</td></tr>
<tr><td>headerColumn</td><td style="text-align: center">피벗 테이블의 헤더로 사용할 컬럼.</td><td style="text-align: center">"PLAN_DATE"</td></tr>
<tr><td>groupCds</td><td style="text-align: center">Group By에 사용될 컬럼들의 배열.</td><td style="text-align: center">{"PLANT_ID", "DEMAND_ID", "ROUTE_CODE"}</td></tr>
<tr><td>dataColumns</td><td style="text-align: center">피벗 테이블에서 값을 표시할 데이터 컬럼들의 배열.</td><td style="text-align: center">{"QTY", "HOLIDAY_YN"}</td></tr>
<tr><td>measureNms</td><td style="text-align: center">데이터 값이 나눠진 경우(측정값 분리 시) 사용하는 분류명. 보통 groupCds에 포함되어 사용할 일이 없지만 DB 데이터로 주어지지 않을 경우 사용.</td><td style="text-align: center">{"A_QTY", "B_QTY", "C_QTY"}</td></tr>
<tr><td>additionalHeaderColumns</td><td style="text-align: center">추가적으로 헤더에 포함할 컬럼.</td><td style="text-align: center">{"PLAN_DATE","WEEK","ETC"}</td></tr>
</tbody></table>
</div>
<p>시나리오 1 : 일반 pivot</p>
<pre><code class="language-java">String headerColumn ="PLAN_DATE"; 
String[] groupCds = {"PLANT_ID","DEMAND_ID","ROUTE_CODE","RESOURCE_CODE"}; 
String[] dataColumns = {"QTY", "HOLIDAY_YN"}; 
String[] measureNms = {}; 
String[] additionalHeaderColumns = {}; 
return PivotUtil.pivotData(dataList, headerColumn, groupCds, dataColumns, measureNms, additionalHeaderColumns);
</code></pre>
<p>결과</p>
<pre><code>{
  "ROUTE_NAME": "1차가공",
  "PLAN_DATE": "2024-08-23",
  "HOLIDAY_YN": "N",
  "RESOURCE_CODE": "KRS-020110",
  "QTY": [
    1,
    1,
    1,
    1,
    1,
    10,
    100,
    55
  ],
  "PLANT_ID": "4205",
  "DEMAND_ID": "F0170006-K1-0001",
  "RESOURCE_NAME": "가공",
  "ROUTE_CODE": "KRT-020101"
}
</code></pre>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<p>시나리오2 : Measure 가 있지만 DB에서 Measure 값을 리턴하지 않아서 임의로 표시해야하는 경우
다국어 처리시  measureNms 에는 다국어 코드값을 넣고 realgrid displayCallback 을 이용해 다국어 표시</p>
<pre><code class="language-javascript">{name: "QTY_TYPE", dataType: "text", headerText :"QTY_TYPE" , visible: true, editable: false, width: 100,
  displayCallback: function (grid, index, val) {
    return transLangKey(val);
  },
},
</code></pre>
<pre><code class="language-java">String headerColumn ="PLAN_DT";
String[] groupCds = {"PLNT_CD", "VERSION_CD", "ITEM_CD"};
String[] dataColumns = {"BOH_QTY", "GI_QTY", "GR_QTY", "EOH_QTY", "FLAG"};
String[] measureNms = {"기초재고", "출고예정", "입고예정", "기말재고"}; //다국어 컬럼명
String[] additionalHeaderColumns = {};
return PivotUtil.pivotData(dataList, headerColumn, groupCds, dataColumns, measureNms, additionalHeaderColumns);


</code></pre>
<p>샘플 데이터 형태</p>
<div class="table-wrapper"><table><thead><tr><th>PLNT_CD</th><th style="text-align: center">PLNT_NM</th><th style="text-align: center">VERSION_CD</th><th style="text-align: center">ITEM_CD</th><th style="text-align: center">ITEM_NM</th><th style="text-align: center">PLAN_DT</th><th style="text-align: center">BOH_QTY</th><th style="text-align: center">GI_QTY</th><th style="text-align: center">GR_QTY</th><th style="text-align: center">EOH_QTY</th><th style="text-align: center">FLAG</th></tr></thead><tbody>
<tr><td>1100</td><td style="text-align: center">울산공장</td><td style="text-align: center">U1-20240723-003-003</td><td style="text-align: center">D00001</td><td style="text-align: center">Adipic Acid</td><td style="text-align: center">20240723</td><td style="text-align: center">1000</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">Y</td></tr>
<tr><td>1100</td><td style="text-align: center">울산공장</td><td style="text-align: center">U1-20240723-003-003</td><td style="text-align: center">D00001</td><td style="text-align: center">Adipic Acid</td><td style="text-align: center">20240724</td><td style="text-align: center">2000</td><td style="text-align: center">2</td><td style="text-align: center">0</td><td style="text-align: center">2</td><td style="text-align: center">Y</td></tr>
<tr><td>1100</td><td style="text-align: center">울산공장</td><td style="text-align: center">U1-20240723-003-003</td><td style="text-align: center">D00001</td><td style="text-align: center">Adipic Acid</td><td style="text-align: center">20240725</td><td style="text-align: center">3000</td><td style="text-align: center">3</td><td style="text-align: center">0</td><td style="text-align: center">3</td><td style="text-align: center">Y</td></tr>
</tbody></table>
</div>
<p>결과</p>
<pre><code>{
    "ITEM_CD": "D00001",
    "ITEM_NM": "Adipic Acid",
    "PLNT_NM": "울산공장",
    "PLNT_CD": "1100",
    "FLAG": [
        "Y",
        "Y",
        "Y",
    ],
    "QTY_TYPE": "기초재고",
    "QTY": [
        1000,
        2000,
        3000
    ],
    "VERSION_CD": "U1-20240723-004-003",
    "PLAN_DT": "20240723",
},
{
    "ITEM_CD": "D00001",
    "ITEM_NM": "Adipic Acid",
    "PLNT_NM": "울산공장",
    "PLNT_CD": "1100",
    "FLAG": [
        "Y",
        "Y",
        "Y",
    ],
    "QTY_TYPE": "출고예정",
    "QTY": [
        1,
        2,
        3
    ],
    "VERSION_CD": "U1-20240723-004-003",
    "PLAN_DT": "20240723",
},
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>구분</th><th style="text-align: center">2024-01</th><th style="text-align: center">2024-02</th></tr></thead><tbody>
<tr><td>기초재고</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td>출고예정</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td>입고예정</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td>기말재고</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
</tbody></table>
</div><br/>
<br/>
<br/>
<br/>
<br/>
<p>시나리오3 : 헤더에 부가적인 정보를 DB 데이터로 표현 해달라고 하는 경우</p>
<div class="table-wrapper"><table><thead><tr><th>2024-01</th><th style="text-align: center">2024-02</th></tr></thead><tbody>
<tr><td>W01</td><td style="text-align: center">W02</td></tr>
<tr><td>1월</td><td style="text-align: center">2월</td></tr>
<tr><td>1</td><td style="text-align: center">1</td></tr>
<tr><td>1</td><td style="text-align: center">1</td></tr>
<tr><td>1</td><td style="text-align: center">1</td></tr>
<tr><td>1</td><td style="text-align: center">1</td></tr>
</tbody></table>
</div>
<pre><code class="language-java">String headerColumn ="PLAN_DATE"; 
String[] groupCds = {"PLANT_ID","DEMAND_ID","ROUTE_CODE","RESOURCE_CODE"}; 
String[] dataColumns = {"QTY", "HOLIDAY_YN"}; 
String[] measureNms = {}; 
String[] additionalHeaderColumns = {"PLAN_DATE","WEEK","MONTH"}; 
return PivotUtil.pivotData(dataList, headerColumn, groupCds, dataColumns, measureNms, additionalHeaderColumns);
</code></pre>
<hr />
<h3 id="font-end"><a class="header" href="#font-end">font-end</a></h3>
<p>이 자료에서는 주어진 React 소스를 통해 그리드 데이터를 조회하고, 피벗 테이블을 생성 및 표시하는 방법을 설명합니다. 이 코드의 주요 목적은 데이터를 서버로부터 불러와 동적으로 컬럼을 생성하고, 그리드에 데이터를 표시하는 것입니다.</p>
<p>pivot Grid는 Context Menu의 레이아웃 저장/삭제 기능을 사용하지 않기 때문에 <code>dynamic={true}</code> 를 설정한다.</p>
<pre><code> &lt;BaseGrid id="grid1" items={grid1Items} afterGridCreate={afterGrid1Create} dynamic={true}/&gt;
</code></pre>
<ol>
<li>데이터 조회 (<code>loadData</code> 함수)** <code>loadData</code> 함수는 서버에서 데이터를 조회하는 역할을 합니다.</li>
</ol>
<pre><code class="language-javascript">const loadData = () =&gt; {
  let param = {
    p_GENDOR : getValues('gender'),  // 성별 선택값
    P_START_DT : getValues('startDt'),  // 시작일 선택값
  };

  zAxios({
    method: 'post',
    header: { 'content-type': 'application/json' },
    url: baseURI() + 'practice/q3',  // 요청을 보낼 서버 URL
    data: param
  })
  .then(function (res) {
    if (res.status === HTTP_STATUS.SUCCESS) {  // 서버 응답이 성공적일 경우
      makeCrossTabFieldsAndColumns(res.data.header);  // 동적 컬럼 생성 함수 호출
      setCrossTabGridData(res.data.header, res.data.data);  // 그리드에 데이터 설정
    }
  })
  .catch(function (err) {
    console.log(err);  // 에러 발생 시 로그 출력
  });
};
</code></pre>
<ul>
<li><strong><code>zAxios</code></strong> : axios 기반으로 만든 서버에 요청을 보내는 비동기 함수입니다.
<ul>
<li><u>waitOn: false, 옵션을 추가하면 progress 가 나타나지 않습니다.</u></li>
</ul>
<pre><code class="language-javascript">zAxios({
  method: 'post',
  header: { 'content-type': 'application/json' },
  url: baseURI() + 'practice/q3',  // 요청을 보낼 서버 URL
  data: param,
  waitOn: false
})
</code></pre>
</li>
</ul>
<ol start="2">
<li>동적 컬럼 생성 (<code>makeCrossTabFieldsAndColumns</code> 함수)**
이 함수는 서버로부터 받아온 헤더 데이터를 기반으로 그리드에 동적 컬럼을 추가합니다. 각 날짜별로 새로운 컬럼을 생성하고, 그 컬럼을 그리드에 추가합니다.</li>
</ol>
<pre><code class="language-javascript">function makeCrossTabFieldsAndColumns(dateHeaders) {
  let dynamicCols = [];
  dateHeaders.forEach(dateHeader =&gt; {
    let dateHeaderSplit = dateHeader.split("-");
    const date = new Date(dateHeaderSplit[0], dateHeaderSplit[1]-1, dateHeaderSplit[2]);
    dynamicCols.push(
      { 
        name: dateHeader, 
        dataType: 'number',
        headerText: date.format("yyyy/MM/dd"),
        visible: true,
        editable: true, 
        width: 80,
      },
    );
  });   
  grid1.addGridItems(grid1Items.concat(dynamicCols), true);  // 기존 컬럼에 동적 컬럼을 추가
}
</code></pre>
<ul>
<li>
<p><strong><code>dateHeaders</code></strong> : 서버로부터 받아온 날짜별 헤더 리스트입니다.</p>
</li>
<li>
<p><strong><code>dynamicCols</code></strong> : 동적으로 생성된 컬럼 객체 배열입니다.</p>
</li>
<li>
<p><strong><code>addGridItems</code></strong> : 기존의 컬럼 배열에 동적으로 생성된 컬럼을 추가합니다.</p>
</li>
</ul>
<ol start="3">
<li>데이터 그리드에 설정 (<code>setCrossTabGridData</code> 함수)**
이 함수는 동적으로 생성된 컬럼과 데이터를 그리드에 설정합니다. 서버로부터 받은 데이터 배열을 가공하여 그리드에 채웁니다.</li>
</ol>
<pre><code class="language-javascript">function setCrossTabGridData(dateHeaders, data) {
  let jsonData = [];
  data.map(function (dataRow) {
    let obj = {};
    obj = Object.assign(obj, dataRow);  // 데이터 행을 복사하여 객체에 할당
    dateHeaders.map(function (val, idx) {
      obj[val] = dataRow["QTY"][idx];  // 날짜별 데이터를 해당 컬럼에 할당
    });
    jsonData.push(obj);  // 가공된 데이터를 배열에 추가
  });

  grid1.dataProvider.fillJsonData(jsonData);  // 가공된 데이터를 그리드에 채움
}
</code></pre>
<h4 id="pivot-저장"><a class="header" href="#pivot-저장">pivot 저장</a></h4>
<ul>
<li><strong><code>getUpdatedCells</code></strong> : 지정된 행의 수정된 셀 데이터들을 확인한다.</li>
</ul>
<pre><code class="language-javascript">function saveData() {
    grid1.gridView.commit(true);
    showMessage(transLangKey('MSG_CONFIRM'), transLangKey('MSG_SAVE'), function (answer) {
    if (answer) {
      let changeRowData = [];
      let changes = [];

      changes = changes.concat(
        grid1.dataProvider.getAllStateRows().created,
        grid1.dataProvider.getAllStateRows().updated,
        grid1.dataProvider.getAllStateRows().deleted,
        grid1.dataProvider.getAllStateRows().createAndDeleted
      );

      changes.forEach(function (row) {
        let data = grid1.dataProvider.getJsonRow(row);
        changeRowData.push(data);
      });

      if (changeRowData.length === 0) {
        //저장 할 내용이 없습니다.
        showMessage(transLangKey('MSG_CONFIRM'), transLangKey('MSG_5039'), { close: false });
      } else {
        if (answer) {
          let arrUpdateData = [];
          if(changes.length &gt; 0){
            changes.forEach(function (row) {
              let rowData = grid1.dataProvider.getJsonRow(row);
              const updatedCells = grid1.dataProvider.getUpdatedCells([row]);
              let headerGrps = [];
              updatedCells.map(cellRow =&gt; {
                const cells = cellRow.updatedCells
                cells.map(field =&gt; {
                  let date = field.fieldName;
                  if(headerGrps.indexOf(date) == -1) {
                    headerGrps.push(date);
                  }
                });
              });

              headerGrps.map(field =&gt; {
                let updData = {
                  PLANT_ID: rowData['PLANT_ID'],
                  DEMAND_ID: rowData['DEMAND_ID'],
                  ROUTE_CODE: rowData['ROUTE_CODE'],
                  RESOURCE_CODE: rowData['RESOURCE_CODE'],
                  BASE_DATE: field,
                  QTY: rowData[field],
                }; 
                arrUpdateData.push(updData);
              });
            });
          }
          console.log("arrUpdateData", arrUpdateData);
        }
      }
    }
    });
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="팝업"><a class="header" href="#팝업">팝업</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Practice06.jsx</code>, <code>PopName.jsx</code></p>
<p>이 예제는 두 가지 상황에서 팝업을 호출하고 데이터를 가져오는 방법을 보여줍니다. 팝업을 호출하고 confirm props 를 통해 팝업에서 데이터를 가져오는 방법은 거의 동일합니다.</p>
<ol>
<li>Search 영역의 Input에서 팝업 호출: 사용자가 Search 영역의 입력 필드를 통해 팝업을 호출하는 예제입니다.</li>
<li>Grid 영역에서 팝업 호출: Grid 영역에서 팝업을 호출하여 데이터를 가져오는 샘플입니다</li>
</ol>
<h3 id="팝업-구성"><a class="header" href="#팝업-구성">팝업 구성</a></h3>
<ul>
<li>PopupDialog 컴포넌트로 팝업을 구현</li>
<li>PopupDialog props: open, onClose , onSubmit, title, resizeHeight, resizeWidth, checks
<ul>
<li>
<p>resizeWidth : default 400, popup창 가로 크기</p>
</li>
<li>
<p>resizeHeight : default 300, popup창 세로 크기</p>
</li>
<li>
<p><code>checks</code></p>
<p>기본적으로 화면(이너탭)삭제, 조회, 팝업 닫기 할 때 그리드의 업데이트 체크를 하여
'저장되지 않은 데이터가 있습니다, 계속하시겠습니까?' 와 같은 알림 메세지를 띄웁니다.
이에 여러 예외 케이스가 발생되어 개선할 수 있도록 가이드를 드립니다.
1.팝업 그리드의 변경 사항에 대해 메인 그리드의 업데이트 상태 체크에 영향을 주지 않기 위해 아래와 같이 설정합니다.</p>
<p>checks props 로 설정한 그리드에 대해서만 업데이트 상태를 체크하도록 합니다.</p>
<pre><code class="language-javascript">&lt;PopupDialog type="NOBUTTONS" open={props.open} onClose={props.onClose} checks={[itemGroupMasterGrid]} ~ &gt;
</code></pre>
<p>위의 설정이 없는 화면의 경우에서는 모든 그리드(팝업그리드, parent그리드)를 체크하는 것을 기본으로 합니다</p>
</li>
</ul>
</li>
</ul>
<h4 id="그리드에서의-팝업호출"><a class="header" href="#그리드에서의-팝업호출">그리드에서의 팝업호출</a></h4>
<pre><code class="language-javascript"> const [namePopupOpen, setNamePopupOpen] = useState(false);


  //grid button click
  gridView.onCellButtonClicked = (grid, itemIndex, column) =&gt; {
      if (column.fieldName === "KORNAME") {
        setNamePopupOpen(true);
      }
  };

  {namePopupOpen &amp;&amp; &lt;PopName open={namePopupOpen} onClose={() =&gt; setNamePopupOpen(false)} confirm={confirmNamePopup} /&gt;}

  //팝업에서 가져온 데이터 셋팅
  const confirmNamePopup = (dataRows) =&gt; {
    let itemIndex = grid1.gridView.getCurrent().itemIndex;
    grid1.gridView.beginUpdateRow();  
    grid1.gridView.setValue(itemIndex, "KORNAME", dataRows[0].NAME);
  }

</code></pre>
<h4 id="search-영역의-input-에서의-팝업호출"><a class="header" href="#search-영역의-input-에서의-팝업호출">Search 영역의 Input 에서의 팝업호출</a></h4>
<pre><code class="language-javascript">  const [namePopupOpen2, setNamePopupOpen2] = useState(false);

  &lt;InputField type="action" name="action" label={transLangKey("팝업")} control={control} onClick={()=&gt; setNamePopupOpen2(true)}&gt;&lt;Icon.Search /&gt;&lt;/InputField&gt;


  {namePopupOpen2 &amp;&amp; &lt;PopName open={namePopupOpen2} onClose={() =&gt; setNamePopupOpen2(false)} confirm={confirmNamePopup2} /&gt;}

  //팝업 에서 가져온 데이터 셋팅
  const confirmNamePopup2 = (dataRows) =&gt; {
    setValue('action', dataRows[0].NAME);
  }
</code></pre>
<h4 id="zaxios"><a class="header" href="#zaxios">zAxios</a></h4>
<p>팝업에서 zAxios 호출 시 waitOn이 parent 영역이 아닌 popup 영역에서 작동되도록 <strong><code>fromPopup: true</code></strong> 를 붙인다.
fromPopup: true</p>
<pre><code class="language-javascript">zAxios({      
      method: "post",
      url: "url",
      data: param,
      fromPopup: true,
    }).then(function (res) {

    }).catch(function (err) {
      console.log(err);
    });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="팝업-1"><a class="header" href="#팝업-1">팝업</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Practice07.jsx</code></p>
<ol>
<li>input 유효성 검사</li>
</ol>
<ul>
<li><a href="https://react-hook-form.com/docs/useform/register#options">reack-hook-form validation</a></li>
<li>List of validation rules supported:
<ul>
<li>required</li>
<li>min</li>
<li>max</li>
<li>minLength</li>
<li>maxLength</li>
<li>pattern</li>
<li>validate</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">import { onErrorInput } from "@zionex/wingui-core/utils/common";
 // globalButtons
  const globalButtons = [
    { name: 'search', action: (e) =&gt; { handleSubmit(loadData, onErrorInput)() }, visible: true, disable: false },
    { name: "refresh", action: (e) =&gt; { refresh() }, visible: true, disable: false },
  ];

&lt;InputField type="select" name="gender" control={control} label={transLangKey('GENDER')} options={genderOption} rules={{ required: transLangKey('FP_MSG_FIELD_REQUIRED') }}/&gt;
        &lt;InputField type="text" name="test" control={control} label={transLangKey('TEST')} rules={{ required: transLangKey('FP_MSG_FIELD_REQUIRED') }}/&gt;
        &lt;InputField type="number" name="test2" control={control} label={transLangKey("TEST2")}
          rules={{
            maxLength: {
              value: 2,
              message: "error message",
            },
          }}
        /&gt;
        &lt;InputField type="text" name="test3" control={control} label={transLangKey("TEST3")}
          rules={{
            pattern: {
              value: /[A-Za-z]{3}/,
              message: 'error message' 
            }
          }}
        /&gt;
</code></pre>
<ol start="2">
<li>grid 컬럼 유효성 검사</li>
</ol>
<ul>
<li>criteria
<ul>
<li>required: 필수 입력 여부를 검증합니다.</li>
<li>values: 허용되는 값의 목록 내에 있는지 검증합니다.</li>
<li>maxLength: 입력된 값의 최대 길이를 검증합니다.</li>
<li>min, max: 최소 및 최대 값 제한을 검증합니다.</li>
<li>lessThan, lessOrEqualThan, biggerThan, biggerOrEqualThan: 다른 필드 값과 비교하여 크기 제한을 검증합니다.</li>
<li>inputChar: 입력된 문자의 유효성을 검증합니다.</li>
<li>validFunc: 사용자 정의 함수에 의한 유효성을 검증합니다.</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript"> gridView.onValidateColumn = (grid, column, inserting, value, itemIndex) =&gt; {
      let error = {};
      if (inserting) {
        return;
      }

      let headerText = getHeaderText(grid, column.name);
      const rules = getColumnValidRules(column.fieldName);

      if (rules !== undefined) {
        rules.forEach((rule) =&gt; {
          let valid = rule.valid;
          if (rule.criteria === 'required' &amp;&amp; (value === undefined || value === null || value.length &lt;= 0)) {
            error.level = 'warning';
            //MSG_CHECK_VALID_002 : '{{headerText}}는 필수값입니다.'
            error.message = transLangKey('MSG_CHECK_VALID_002', { headerText })
          } else if (rule.criteria === 'values') {
            if (Array.isArray(valid) &amp;&amp; !valid.inclues(value)) {
              error.level = 'warning';
              //MSG_CHECK_VALID_001 : '{{headerText}}값은 {{val}}중 하나여야 합니다.'
              error.message = transLangKey('MSG_CHECK_VALID_001', { headerText: headerText, val: valid })
            }
          } else if (rule.criteria === 'maxLength' &amp;&amp; (value &amp;&amp; value.length &gt; valid)) {
            error.level = 'warning';
            //MSG_CHECK_VALID_003 : '{{headerText}}길이는 {{val}}보다 작아야 합니다.'
            error.message = transLangKey('MSG_CHECK_VALID_003', { headerText: headerText, val: valid })
          }
          // min
          if (rule.criteria === 'min' &amp;&amp; (value &lt; valid)) {
            error.level = 'warning';
            //MSG_CHECK_VALID_004 : '{{headerText}}값은 {{val}}보다 커야 합니다.'
            error.message = transLangKey('MSG_CHECK_VALID_004', { headerText: headerText, val: valid })
          } else if (rule.criteria === 'max' &amp;&amp; (value &gt; rule.valid)) {
            error.level = 'warning';
            //MSG_CHECK_VALID_005 : '{{headerText}}값은 {{val}}보다 작아야 합니다.'
            error.message = transLangKey('MSG_CHECK_VALID_005', { headerText: headerText, val: valid })
          } else if (rule.criteria === 'lessThan') {
            let val = grid.getValue(itemIndex, valid);
            if (value &amp;&amp; value &gt;= val) {
              error.level = 'warning';
              //MSG_CHECK_VALID_005 : '{{headerText}}값은 {{val}}보다 작아야 합니다.'
              error.message = transLangKey('MSG_CHECK_VALID_005', { headerText: headerText, val: valid })
            }
          } else if (rule.criteria === 'lessOrEqualThan') {
            let val = grid.getValue(itemIndex, valid);
            if (value &amp;&amp; value &gt; val) {
              let aHeadText = getHeaderText(grid, valid)
              error.level = 'warning';
              //MSG_CHECK_VALID_007 : '{{headerText}}값은 {{val}}값보다 작거나 같아야 합니다.'
              error.message = transLangKey('MSG_CHECK_VALID_007', { headerText: headerText, val: aHeadText })
            }
          } else if (rule.criteria === 'biggerThan') {
            let val = grid.getValue(itemIndex, valid);
            if (value &amp;&amp; value &lt;= val) {
              let aHeadText = getHeaderText(grid, valid)
              error.level = 'warning';
              //MSG_CHECK_VALID_008 : '{{headerText}}값은 {{aHeadText}}값보다 커야 합니다.'
              error.message = transLangKey('MSG_CHECK_VALID_008', { headerText: headerText, val: aHeadText })
            }
          } else if (rule.criteria === 'biggerOrEqualThan') {
            let val = grid.getValue(itemIndex, valid);
            if (value &amp;&amp; value &lt; val) {
              let aHeadText = getHeaderText(grid, valid)

              error.level = 'warning';
              //MSG_CHECK_VALID_009 : '{{headerText}}값은 {{aHeadText}}값보다 크거나 같아야 합니다.'
              error.message = transLangKey('MSG_CHECK_VALID_009', { headerText: headerText, val: aHeadText })
            }
          } else if (rule.criteria == 'inputChar') {
            err = checkInputCharValid(headerText, valid, value);
            if (err != true) {
              error.level = 'warning';
              error.message = err.message;
            } else {
              error.level = 'ignore'
            }
          } else if (rule.criteria == 'validFunc') {
            let err = valid(grid, column, value, itemIndex);
            if (err != true) {
              error.level = 'warning';
              error.message = err.message;
            }
          }
        });
      }

      return error;
    }
</code></pre>
<pre><code class="language-javscript">  {name: "RES_CD", dataType: "text", headerText :"AK_RES_CODE" , visible: true, editable: true, width: 100, validRules: [{ criteria: "required" }] },
  {name: 'SVC_LEV', dataType: 'number', headerText: 'SVC_LEV', visible: true, editable: true, width: 80,  validRules: [{criteria: "min", valid: "50"}, {criteria: "max", valid: "99.9"}]},
  {name: "email", dataType: "text", headerText: "EMAIL", editable: true, width: 100, validRules: [{ criteria: "inputChar", valid: "email" }] },
  {name: "processTimeTpCd", dataType: "text", headerText: "FP_PROCESS_TM_TP_CD", visible: true, editable: true, width: 80, textAlignment: "center", defaultValue: "N",
    validRules: [{ criteria: "validFunc", valid: (grid, column, value, itemIndex) =&gt; {
        if (grid.getValue(itemIndex, 'SVC_LEV') &gt; 100 &amp;&amp; !value) {
          return { message: transLangKey('FP_MSG_RULE_OF_PROCESS_TM_TP_CD', { headerText: transLangKey('FP_PROCESS_TM_TP_CD') }) };
        } else {
          return true;
        }
      }
    }],
  },
</code></pre>
<h4 id="grid-시작일-종료일-체크"><a class="header" href="#grid-시작일-종료일-체크">grid 시작일 종료일 체크</a></h4>
<pre><code class="language-javascript">gridView.onEditRowChanged = function (grid, itemIndex, dataRow, field, oldValue, newValue) {
      let fieldName = dataProvider.getFieldName(field);
      if (fieldName === 'START_DT'){ 
        let enddate =  grid.getValue(itemIndex, "END_DT")
        if(enddate != undefined){
          if(newValue &gt; enddate){
            showMessage(transLangKey("WARNING"), transLangKey('MSG_0007'));
            grid.setValue(itemIndex, "getValue", null);
          }
        }
      }else if (fieldName === 'END_DT'){ //END_DATE
        let stddate =  grid.getValue(itemIndex, "START_DT")
        if(stddate != undefined){
          if(newValue &lt; stddate){
            showMessage(transLangKey("WARNING"), transLangKey('MSG_0007'));
            grid.setValue(itemIndex, "END_DT", null);
          }
        }
      }
    };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="차트"><a class="header" href="#차트">차트</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Practice08.jsx</code></p>
<p>chartjs2 의 사용법과 동일.
<a href="https://github.com/reactchartjs/react-chartjs-2">react-chartjs2 github</a></p>
<h4 id="1-필요한-라이브러리-임포트"><a class="header" href="#1-필요한-라이브러리-임포트">1. 필요한 라이브러리 임포트</a></h4>
<pre><code class="language-javascript">import React, { useState, useEffect, useRef } from 'react';
import { useForm } from 'react-hook-form';
import ChartComponent from "@zionex/wingui-core/component/chart/ChartComponent";
</code></pre>
<h4 id="2-차트-데이터-및-옵션-상태-설정"><a class="header" href="#2-차트-데이터-및-옵션-상태-설정">2. 차트 데이터 및 옵션 상태 설정</a></h4>
<pre><code class="language-javascript">const chart1 = useRef(null);
const [chartData1, setChartData1] = useState({ datasets: [] });
const [chartOption1, setChartOption1] = useState();
</code></pre>
<h4 id="3-useeffect를-사용하여-차트-옵션-설정"><a class="header" href="#3-useeffect를-사용하여-차트-옵션-설정">3. useEffect를 사용하여 차트 옵션 설정</a></h4>
<pre><code class="language-javascript">useEffect(() =&gt; {
  setChartOption1({
    // 차트 옵션 설정
  });
  
  loadData();
}, []);
</code></pre>
<h4 id="4-차트-데이터-로드-함수-구현"><a class="header" href="#4-차트-데이터-로드-함수-구현">4. 차트 데이터 로드 함수 구현</a></h4>
<pre><code class="language-javascript">const loadData = () =&gt; {
  setChartData1({
    labels: ['01월','02월','03월','04월','05월','06월','07월','08월'],
    datasets: [
      // 데이터셋 설정
    ],
  });
};
</code></pre>
<h4 id="5-차트-렌더링"><a class="header" href="#5-차트-렌더링">5. 차트 렌더링</a></h4>
<pre><code class="language-javascript">&lt;ChartComponent
  options={chartOption1}
  dataset={chartData1}
  ref={chart1}
  config={false}
  plugins={[]}
&gt;&lt;/ChartComponent&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="다국어"><a class="header" href="#다국어">다국어</a></h2>
<h3 id="다국어-기능-설명"><a class="header" href="#다국어-기능-설명">다국어 기능 설명</a></h3>
<p><strong>1. 다국어 변환 적용 범위</strong></p>
<ul>
<li>
<p><strong>Grid Header</strong> 와 <strong>Popup Title</strong> 에는 자동으로 다국어 변환 코드가 적용됩니다.</p>
</li>
<li>
<p>그러나 <strong>Input 필드</strong> 에는 자동으로 다국어 변환이 적용되지 않으므로 별도로 처리해야 합니다.</p>
</li>
</ul>
<p><strong>2. 다국어 등록 방법</strong></p>
<ul>
<li><strong>설정 &gt; 환경설정 &gt; 다국어</strong>  메뉴를 통해 새로운 다국어를 등록할 수 있습니다.</li>
</ul>
<p><strong>3. 다국어 코드 형식</strong></p>
<ul>
<li>다국어 코드는 <strong>CONSTANT_CASE</strong>  형식을 사용하여 정의됩니다.</li>
</ul>
<p><strong>4. 언어 및 포맷 설정</strong></p>
<ul>
<li>화면 우측 상단의 언어 및 포맷 설정에 표시되는 언어 리스트는 <strong>application.yaml</strong>  파일에서 구성됩니다.</li>
</ul>
<p><strong>5. 다국어 적용 방법</strong></p>
<ul>
<li>신규로 등록한 다국어는 화면을 새로 고침하거나, 다국어 메뉴에서 <strong>강제적용</strong>  버튼을 클릭할 때 적용됩니다.</li>
</ul>
<pre><code class="language-yaml">app:
 languages:
   - en
   - ja
   - ko
   - zh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lookuptree"><a class="header" href="#lookuptree">LookupTree</a></h2>
<p><strong>샘플 파일명:</strong>  <code>Practice09.jsx</code>, <code>areacodes.js</code></p>
<blockquote>
<p>컬럼에 연결된 데이터 필드의 실제 값 대신 그 값과 연관된 다른 값을 셀에 표시합니다. 보통 상위 컬럼 값에 따라 자기 컬럼의 dropDown 목록이 변경되는경우 사용합니다.</p>
</blockquote>
<ul>
<li>Plant 별로 dropdown 이 별도로 구성되어야 할때 주로 사용함 ( ex: plant 별 item 구성)</li>
<li>리얼그리드 이벤트로 강제로 만들 수는 있으나 권장하지 않음.</li>
</ul>
<p><a href="https://docs.realgrid.com/guides/cell-components/lookup-tree">참고링크</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="web-application-build"><a class="header" href="#web-application-build">Web Application Build</a></h2>
<p>Visual Studio Code(이하 VS Code) 개발 툴을 기준으로 설명합니다.</p>
<p>모든 작업에 앞서, 최신의 source를 유지해야 합니다.</p>
<ul>
<li>mvnw command 가 없다면 maven 을 PC에 별도로 설치해야합니다. <a href="https://maven.apache.org/download.cgi">다운로드링크</a></li>
</ul>
<h3 id="build-절차"><a class="header" href="#build-절차">Build 절차</a></h3>
<ol>
<li>
<p><strong>VS Code의 Terminal 열기</strong></p>
</li>
<li>
<p><strong>명령어 입력</strong></p>
</li>
</ol>
<pre><code class="language-sh">   .\mvnw clean package
</code></pre>
<ol start="2">
<li><strong>배포 환경 별 Profile 적용</strong></li>
</ol>
<ul>
<li>배포 환경 별로 application.yaml을 작성해놨다가 빌드 시 원하는 환경의 profile로 설정하여 빌드할 수 있습니다.</li>
<li>프로파일 설정을 하지 않고 빌드 시 기본 local 폴더의 profile이 포함되어 빌드가 되며 “-P 배포환경 ID” 명령어로 설정 가능합니다.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>환경</th><th>파일 경로</th><th>profile ID</th><th>명령어</th></tr></thead><tbody>
<tr><td>로컬</td><td>local &gt; application.yaml</td><td>local</td><td>.\mvnw clean package</td></tr>
<tr><td>개발</td><td>develop &gt; application.yaml</td><td>dev</td><td>.\mvnw clean package -P dev</td></tr>
<tr><td>운영</td><td>production &gt; application.yaml</td><td>prod</td><td>.\mvnw clean package -P prod</td></tr>
</tbody></table>
</div>
<ul>
<li>예시) 운영 환경에 배포할 profile로 적용하고 싶을 경우, 아래 명령어로 실행</li>
</ul>
<pre><code>.\mvnw clean package -P prod
</code></pre>
<ol start="4">
<li><strong>WAR(Web application ARchive) 파일 생성 확인</strong></li>
</ol>
<ul>
<li>target 폴더 하위에 <code>T3series-wingui-버전.war</code> 파일이 생성되어야 합니다.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
